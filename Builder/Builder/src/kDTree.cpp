#include <windows.h>
#include <gl/gl.h>
#include <gl/glu.h>
//#include <gl/glut.h>


#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <algorithm>

#include "kDTree.h"

// easy macros for working with the compressed BSP tree
// structure that is a bit hard to understand otherwise
// (and access may vary on whether OOC mode is on or not)

#if COMMON_COMPILER == COMPILER_MSVC
// disable portability warnings generated by 
// pointer arithmetic in code
#pragma warning( disable : 4311 4312 4102 )
#endif 

// surface area of a voxel:
__inline float surfaceArea(float dim1, float dim2, float dim3) {
	return 2.0f * ((dim1 * dim2) + (dim2 * dim3) + (dim1 * dim3));
}

void kDTree::buildTree()
{				
	BSPArrayTreeNode root;
	char tempindexName[MAX_PATH], tempnodesName[MAX_PATH];

	timeBuildStart.set();
	curIndex = 0;

	subdivisionMode = BSP_SUBDIVISIONMODE_NORMAL;

	// Build list with all indices and list of intervals:	
	leftlist[0] = new TriangleIndexList(treeStats.numTris);
	leftlist[1] = new TriangleIndexList(treeStats.numTris);

	for (int i = 0; i < MAXBSPSIZE; i++)
		rightlist[i] = new TriangleIndexList();

	// open temporary file for the indices
	sprintf(tempindexName, "tempindex_%d.tmp", treeID);
	FILE *indexFP = fopen(tempindexName, "wb+");
	// .. and tree nodes
	sprintf(tempnodesName, "tempnodes_%d.tmp", treeID);
	FILE *nodeFP = fopen(tempnodesName, "wb+");

	if (!indexFP) {
		LogManager *log = LogManager::getSingletonPtr();
		log->logMessage(LOG_ERROR, "Unable to write index file tempindex.tmp!");
		return;
	}

	if (!nodeFP) {
		LogManager *log = LogManager::getSingletonPtr();
		log->logMessage(LOG_ERROR, "Unable to write node file tempnodes.tmp!");
		return;
	}

	treeStats.numNodes = 1;	

	// subdivision mode == SAH ? then prepare min/max lists
	// for the triangle coordinates..
	if (subdivisionMode == BSP_SUBDIVISIONMODE_NORMAL) {
		minvals = new Vector3[treeStats.numTris];
		maxvals = new Vector3[treeStats.numTris];

		for (int i = 0; i < treeStats.numTris; i++) {
			const Triangle &tri = trianglelist[i];
			

			(*leftlist[0])[i] = i;

			minvals[i].e[0] = min((*m_pVertexCache)[tri.p[0]].e[0], 
				                  min((*m_pVertexCache)[tri.p[1]].e[0], (*m_pVertexCache)[tri.p[2]].e[0]));
			minvals[i].e[1] = min((*m_pVertexCache)[tri.p[0]].e[1], 
				                  min((*m_pVertexCache)[tri.p[1]].e[1], (*m_pVertexCache)[tri.p[2]].e[1]));
			minvals[i].e[2] = min((*m_pVertexCache)[tri.p[0]].e[2], 
								  min((*m_pVertexCache)[tri.p[1]].e[2], (*m_pVertexCache)[tri.p[2]].e[2]));

			maxvals[i].e[0] = max((*m_pVertexCache)[tri.p[0]].e[0], 
				max((*m_pVertexCache)[tri.p[1]].e[0], (*m_pVertexCache)[tri.p[2]].e[0]));
			maxvals[i].e[1] = max((*m_pVertexCache)[tri.p[0]].e[1], 
				max((*m_pVertexCache)[tri.p[1]].e[1], (*m_pVertexCache)[tri.p[2]].e[1]));
			maxvals[i].e[2] = max((*m_pVertexCache)[tri.p[0]].e[2], 
				max((*m_pVertexCache)[tri.p[1]].e[2], (*m_pVertexCache)[tri.p[2]].e[2]));

			//for (int j = 0; j < 3; j++) {
			//	minvals[i].e[j] = min(tri.p[0]->e[j], min(tri.p[1]->e[j], tri.p[2]->e[j]));
			//	maxvals[i].e[j] = max(tri.p[0]->e[j], max(tri.p[1]->e[j], tri.p[2]->e[j]));
			//}
		}
	}
	else { // all other subdivision modes:
		for (int i = 0; i < treeStats.numTris; i++) {	
			(*leftlist[0])[i] = i;
		}
	}

	// Start subdividing, if we have got triangles
	if (treeStats.numTris > 0 && treeStats.maxDepth > 0) {	
		int idx = 0;
		int useAxis = 0;

		// use largest axis for first subdivision
		Vector3 dim = max - min;

		fseek(nodeFP, sizeof(BSPArrayTreeNode), SEEK_SET);

		if (subdivisionMode == BSP_SUBDIVISIONMODE_SIMPLE) // spatial median
			Subdivide(0, leftlist[0], 0, dim.indexOfMaxComponent(), min, max, indexFP, nodeFP);
		else if (subdivisionMode == BSP_SUBDIVISIONMODE_NORMAL) // Surface area heuristic
			SubdivideSAH(0, leftlist[0], 0, min, max, indexFP, nodeFP);		
	}
	else { // no triangles or depth limit == 0: make root
		
		unsigned int count = (unsigned int)leftlist[0]->size();

		root.indexCount = MAKECHILDCOUNT(count);
		root.indexOffset = 0;
		
		fwrite(&root, sizeof(BSPArrayTreeNode), 1, nodeFP);


		// get real (global) triangle indices
		for (unsigned int cI = 0; cI < count; cI++)
			(*(leftlist[0]))[cI] = triIndexList[(*(leftlist[0]))[cI]];

		// write vector to file:
		fwrite(& (*(leftlist[0]))[0], sizeof(int), count, indexFP);
	}

	delete leftlist[0];
	delete leftlist[1];

	for (int k = 0; k < MAXBSPSIZE; k++)
		delete rightlist[k];

	if (subdivisionMode == BSP_SUBDIVISIONMODE_NORMAL) {
		delete[] minvals;
		delete[] maxvals;
		minvals = 0;
		maxvals = 0;
	}

	// read in temporary files
	makeFlatRepresentation(indexFP, nodeFP);

	// remove temporary files (may be huge)
	remove(tempnodesName);
	remove(tempindexName);

	timeBuildEnd.set();
	treeStats.timeBuild = timeBuildEnd - timeBuildStart;
}

void kDTree::makeFlatRepresentation(FILE *indexFP, FILE *nodeFP) {
	LogManager *log = LogManager::getSingletonPtr();
	//log->logMessage(LOG_DEBUG, "Reading in array tree representation from file...");	

	// temporary node file:
	//log->logMessage(LOG_DEBUG, " - read in node list.");	
	tree = new BSPArrayTreeNode[treeStats.numNodes];
	fseek(nodeFP, 0, SEEK_SET);
	fread((void *)tree, sizeof(BSPArrayTreeNode), treeStats.numNodes, nodeFP);
	fclose(nodeFP);

	// temporary index list file:
	//log->logMessage(LOG_DEBUG, " - read in index list.");
	indexlists = new int[treeStats.sumTris];
	fseek(indexFP, 0, SEEK_SET);
	fread((void *)indexlists, sizeof(int), treeStats.sumTris, indexFP);
	fclose(indexFP);
}


bool kDTree::Subdivide(long myOffset, TriangleIndexList *trilist, int depth, int axis, Vector3 &min, Vector3 &max, FILE *indexFP, FILE *nodeFP)
{	
	int i, k;
	unsigned int triCount, newCount[2];
	BSPArrayTreeNode node;
	TriangleIndexList *newlists[2];
	Vector3 newmin = min, 
		newmax = max;
	Vector3 dim;
	long curOffset;

	if (depth == 0) {
		curIndex = 0;
	}

	// Subdivide:

	// mark current file offset
	curOffset = ftell(nodeFP);

	// jump back to own offset
	fseek(nodeFP, myOffset, SEEK_SET);

	// split coordinate is in middle of previous span
	node.splitcoord = (min.e[axis] + max.e[axis]) / 2.0f;

	// set pointer to children and split plane in lower bits 	

	#ifdef KDTREENODE_16BYTES
	
		#ifdef FOUR_BYTE_FOR_KD_NODE
		node.children = (curOffset >> 4);
		node.children2 = axis;
		node.lodIndex = 0;
		#else
		node.children = (curOffset >> 1) | axis;
		#ifndef _USE_CONTI_NODE
		node.children2 = (curOffset + sizeof(BSPArrayTreeNode)) >> 1;
		#endif
		node.lodIndex = 0;
		#endif

	#else
	node.children = (curOffset >> 1) | axis;
	#endif

	// write real data to file
	fwrite(&node, sizeof(BSPArrayTreeNode), 1, nodeFP);

	// jump forward to previous address + size of 2 children -> new current position
	fseek(nodeFP, curOffset + 2*sizeof(BSPArrayTreeNode), SEEK_SET);

	treeStats.numNodes += 2;

	// create new triangle lists
	newlists[0] = leftlist[(depth+1)%2];
	newlists[1] = rightlist[depth];

	newlists[0]->clear();
	newlists[1]->clear();

	// assert 4 byte alignment, or else we mess up our axis marking
	assert(((unsigned int)newlists[0] & 3) == 0);
	assert(((unsigned int)newlists[1] & 3) == 0);

	// go through list, sort triangles into children
	triCount = (unsigned int)trilist->size();

	for (TriangleIndexListIterator j = trilist->begin(); j != trilist->end(); ++j) {
		const Triangle &t = trianglelist[*j];
		
		for (k = 0; k < 3; k++) {
			if ((*m_pVertexCache)[t.p[k]][axis] <= node.splitcoord) {
				newlists[0]->push_back(*j);
				break;
			}
		}

		for (k = 0; k < 3; k++) {
			if ((*m_pVertexCache)[t.p[k]][axis] >= node.splitcoord) {
				newlists[1]->push_back(*j);
				break;
			}
		}

		/*
		for (k = 0; k < 3; k++) {
			if (t.p[k]->e[axis] <= node.splitcoord) {
				newlists[0]->push_back(*j);
				break;
			}
		}

		for (k = 0; k < 3; k++) {
			if (t.p[k]->e[axis] >= node.splitcoord) {
				newlists[1]->push_back(*j);
				break;
			}
		}*/
	}

	trilist->clear();

	newCount[0] = (unsigned int)newlists[0]->size();
	newCount[1] = (unsigned int)newlists[1]->size();

	depth++;

	for (i = 0; i < 2; i++) { 
		long thisChildFileOffset = curOffset + i*sizeof(BSPArrayTreeNode);

		// should we subdivide child further ?
		if ((newCount[i] > (unsigned int)treeStats.maxListLength) && (depth < treeStats.maxDepth) && (newCount[0] + newCount[1] < 2*triCount)) {
			// build new min/max bounding box:
			newmin.e[axis] = min.e[axis] + 0.5f * i * (max.e[axis] - min.e[axis]);
			newmax.e[axis] = min.e[axis] + 0.5f * (i+1) * (max.e[axis] - min.e[axis]);
			dim = newmax - newmin;

			// recursively subdivide further along largest axis
			Subdivide(thisChildFileOffset, newlists[i], depth, dim.indexOfMaxComponent(), newmin, newmax, indexFP, nodeFP);	
			newlists[i]->clear();
		}
		else { // make this child a leaf	
			BSPArrayTreeNode newLeaf;
			unsigned int count = (unsigned int)newlists[i]->size();
			newLeaf.indexCount = MAKECHILDCOUNT(count);
			newLeaf.indexOffset = curIndex;
			curIndex += count;

			// write final node information to file:
			long tempPos = ftell(nodeFP);
			fseek(nodeFP, thisChildFileOffset, SEEK_SET);
			fwrite(&newLeaf, sizeof(BSPArrayTreeNode), 1, nodeFP);
			fseek(nodeFP, tempPos, SEEK_SET);

			// get real (global) triangle indices
			for (unsigned int cI = 0; cI < count; cI++)
				(*(newlists[i]))[cI] = triIndexList[(*(newlists[i]))[cI]];

			// write vector to file:
			fwrite(& (*(newlists[i]))[0], sizeof(int), count, indexFP);

			// statistical information:
			treeStats.numLeafs++;
			treeStats.sumDepth += depth;
			treeStats.sumTris  += count;
			if (depth > treeStats.maxLeafDepth)
				treeStats.maxLeafDepth = depth;
			if (count > treeStats.maxTriCountPerLeaf)
				treeStats.maxTriCountPerLeaf = count;
		}
	}

	return true;
}

bool kDTree::SubdivideSAH(long myOffset, TriangleIndexList *trilist, int depth,  Vector3 &min, Vector3 &max, FILE *indexFP, FILE *nodeFP)
{
	float *mins, *maxs, *collinear;	

	BSPArrayTreeNode node;
	unsigned int triCount = (unsigned int)trilist->size(), newCount[2];
	//BSPTreeNodePtr child[2];
	TriangleIndexList *newlists[2];
	Vector3 newmin = min, newmax = max;
	Vector3 dim;
	int i, k;
	int bestAxis = -1;
	float bestCost = FLT_MAX, bestSplitCoord, currentSplitCoord;
	unsigned int numLeft, numRight;
	unsigned int curMin = 0, curMax = 0, curCol = 0;
	float bestAreaLeft = -1.0f, bestAreaRight = -1.0f, wholeArea = -1.0f;	
	int bestNumLeft = triCount, bestNumRight = triCount;
	long curOffset;
	bool foundFreeSpace = false;

	if (depth == 0) {
		curIndex = 0;		
	}

	bool debug1 = false; // && depth > 30; 
	bool debug2 = false;  //&& triCount == 23;	

	// allocate space for interval values:	
	mins = new float[triCount+1];
	maxs = new float[triCount+1];	
	collinear = new float[triCount+1];

	// for each axis:
	for (int curAxis = 0; curAxis < 3; curAxis++) {		

		// early termination: bb of axis has dimension 0
		if ((max[curAxis] - min[curAxis]) < EPSILON)
			continue;

		// Build sorted list of min and max vals for this axis:
		//
		i = k = 0;
		for (TriangleIndexListIterator j = trilist->begin(); j != trilist->end(); ++j) {
			if (minvals[*j].e[curAxis] == maxvals[*j].e[curAxis]) {
				collinear[k++] = minvals[*j].e[curAxis];
				continue;
			}

			mins[i] = minvals[*j].e[curAxis];
			maxs[i] = maxvals[*j].e[curAxis];

			i++;
		}

		// put guard values at end of array, needed later so we don't go
		// beyond end of array...
		mins[i] = FLT_MAX;
		maxs[i] = FLT_MAX;
		collinear[k] = FLT_MAX;

		// sort arrays:
		std::sort(mins, mins+i);
		std::sort(maxs, maxs+i);
		std::sort(collinear, collinear+k);

		int numMinMaxs = i + 1;
		int numCols = k + 1;				

		unsigned int subtractRight = 0, addLeft = 0;
		unsigned int curMin = 0, curMax = 0, curCol = 0;
		wholeArea = -1.0f;
		currentSplitCoord = -FLT_MAX;

		numLeft = 0;
		numRight = triCount;

		// test for subdivide to create an empty cell:
		float emptySpanBegin = min(mins[0],collinear[0]) - min[curAxis];
		float emptySpanEnd = max[curAxis] - max(maxs[i-1], collinear[k-1]);
		float threshold = treeStats.emptySubdivideRatio * (max[curAxis] - min[curAxis]);

		// empty area to the left?
		if (emptySpanBegin > threshold) {
			bestSplitCoord = currentSplitCoord = min(mins[0],collinear[0]) - 0.01*emptySpanBegin;
			bestCost = 0;
			bestNumLeft = numLeft = 0;
			bestNumRight = numRight = triCount;
			bestAxis = curAxis;

			if (debug1) {		
				cout << "Found free space left: " << emptySpanBegin << " (" << (emptySpanBegin / (max[curAxis] - min[curAxis])) << ")  at Coord " << currentSplitCoord << endl;
				cout << min << " - " << max << " (" << min(mins[0],collinear[0]) << endl;
			}

			foundFreeSpace = true;

			break;
		}
		else if (emptySpanEnd > threshold) { // empty area to the right?
			bestSplitCoord = currentSplitCoord =  max(maxs[i-1], collinear[k-1]) + 0.01*emptySpanEnd;
			bestCost = 0;
			bestNumLeft = numLeft = triCount;
			bestNumRight = numRight = 0;
			bestAxis = curAxis;

			if (debug1) {
				cout << "Found free space right: " << emptySpanEnd << " (" << (emptySpanEnd / (max[curAxis] - min[curAxis])) << ")  at Coord " << currentSplitCoord << endl;
				cout << min << " - " << max << " (" << max(maxs[i-1], collinear[k-1]) << endl;
			}

			foundFreeSpace = true;

			break;
		}
		else {

			//
			// test all possible split planes according to surface area heuristic:
			//

			wholeArea = surfaceArea(max.e[0] - min.e[0], max.e[1] - min.e[1], max.e[2] - min.e[2]);

			if (debug1) {				
				cout << "Find Split curAxis=" << curAxis << " " << min << " - " << max << endl;
				cout << " nTris=" << triCount << " Startcoord = " << currentSplitCoord << endl;
			}

			if (debug2) {
				int l;			
				cout << "Mins: ";
				for (l = 0; l < numMinMaxs; l++)
					cout << mins[l] << " ";
				cout << endl;

				cout << "Maxs: ";
				for (l = 0; l < numMinMaxs; l++)
					cout << maxs[l] << " ";
				cout << endl;

				cout << "Cols: ";
				for (l = 0; l < numCols; l++)
					cout << collinear[l] << " ";
				cout << endl;
			}

			while (mins[curMin] != FLT_MAX || maxs[curMax] != FLT_MAX || collinear[curCol] != FLT_MAX) {
				float newCoord;

				numRight -= subtractRight;
				numLeft  += addLeft;
				addLeft = 0;
				subtractRight = 0;

				do {
					if (collinear[curCol] <= mins[curMin] && collinear[curCol] <= maxs[curMax]) {
						newCoord = collinear[curCol++];

						if (newCoord <= (min.e[curAxis] + max.e[curAxis]) / 2.0f) {
							numLeft++;
							numRight--;
						}
						else {
							addLeft++;
							subtractRight++;
						}
					}
					// find next split coord, either from min or max interval values
					else if (mins[curMin] <= maxs[curMax]) { // take from mins:
						newCoord = mins[curMin++];

						// since this is a minimal value of some triangle, we now have one more
						// triangle on the left side:
						addLeft++;
					}
					else { // take from maxs:
						newCoord = maxs[curMax++];

						// since this is a maximal value of some triangle, we have one less
						// triangle on the right side at the next interval:
						numRight--;
					}
				} while (mins[curMin] == newCoord || maxs[curMax] == newCoord || collinear[curCol] == newCoord);

				if (debug2)
					cout << " [" << i << "] : " << newCoord << endl;

				// don't test if the new split coord is the same as the old one, waste of time..
				if (newCoord == currentSplitCoord || numLeft == 0 || numRight == 0) 
					continue;

				// set new split coord to test
				currentSplitCoord = newCoord;				

				// calculate area on each side of split plane:
				float areaLeft = surfaceArea(currentSplitCoord - min.e[curAxis],  max.e[(curAxis+1)%3] - min.e[(curAxis+1)%3], max.e[(curAxis+2)%3] - min.e[(curAxis+2)%3]) / wholeArea;
				float areaRight = surfaceArea(max.e[curAxis] - currentSplitCoord,  max.e[(curAxis+1)%3] - min.e[(curAxis+1)%3], max.e[(curAxis+2)%3] - min.e[(curAxis+2)%3]) / wholeArea;

				//
				// calculate cost for this split according to SAH:
				//
				float currentCost = BSP_COST_TRAVERSAL + BSP_COST_INTERSECTION * (areaLeft * numLeft + areaRight * numRight);

				if (debug2)
					cout << "  - accepted! cost=" << currentCost << " L:" << numLeft << " R:" << numRight << endl;

				// better than previous minimum?
				if (currentCost < bestCost && numLeft != triCount && numRight != triCount) {
					bestCost = currentCost;
					bestSplitCoord = currentSplitCoord;
					bestNumLeft = numLeft;
					bestNumRight = numRight;
					bestAreaLeft = areaLeft;
					bestAreaRight = areaRight;
					bestAxis = curAxis;
				}
			}
		}

		if (debug1)
			cout << " axis=" << curAxis << " best: cost=" << bestCost << " Split:" << bestSplitCoord << " (L:" << bestNumLeft << " R:" << bestNumRight << ")" << endl;
	}

	// free memory for interval lists
	delete mins;
	delete maxs;
	delete collinear;

	if (debug1) {
		cout << "Best: axis=" << bestAxis << " cost=" << bestCost << " Split:" << bestSplitCoord << " (L:" << bestNumLeft << " R:" << bestNumRight << ")" << endl;
	}

	float subdivisionRatio = (abs((int)triCount - bestNumRight) + abs((int)triCount - bestNumLeft)) / (float)triCount;

	// this subdivision didn't work out... all triangles are still in one of the sides:													
	if (!foundFreeSpace && ((bestNumLeft == triCount && bestNumRight > 0) 
		|| (bestNumLeft > 0 && bestNumRight == triCount)
		|| subdivisionRatio < 0.1f)) {
		return false;
	}

	// determine if cost for splitting would be greater than just keeping this:
	if (depth != 0 && bestCost > (BSP_COST_INTERSECTION * triCount)) {	
		return false;
	}

	// mark current file offset
	curOffset = ftell(nodeFP);

	// jump back to own offset
	fseek(nodeFP, myOffset, SEEK_SET);

	//cout << "Writing BSP tree node to offset " << myOffset << ", Children = " << curOffset << endl;
	//getchar();

	// set split coordinate
	node.splitcoord = bestSplitCoord;

	#ifdef KDTREENODE_16BYTES
	
		#ifdef FOUR_BYTE_FOR_KD_NODE
		// set pointer to children and split plane in lower bits 
		node.children = (curOffset >> 4);
		node.children2 = bestAxis;
		node.lodIndex = 0;
		#else
		// set pointer to children and split plane in lower bits 
		node.children = (curOffset >> 1) | bestAxis;
		#ifndef _USE_CONTI_NODE
		node.children2 = (curOffset + sizeof(BSPArrayTreeNode)) >> 1;
		#endif
		node.lodIndex = 0;
		#endif

	#else
	// set pointer to children and split plane in lower bits 
	node.children = (curOffset >> 1) | bestAxis;
	#endif

	// write real data to file
	fwrite(&node, sizeof(BSPArrayTreeNode), 1, nodeFP);

	// jump forward to previous address + size of 2 children -> new current position
	fseek(nodeFP, curOffset + 2*sizeof(BSPArrayTreeNode), SEEK_SET);

	// we officially have 2 more tree nodes
	treeStats.numNodes += 2;

	// create new triangle lists
	newlists[0] = leftlist[(depth+1)%2];
	newlists[1] = rightlist[depth];
	newlists[0]->clear();
	newlists[1]->clear();

	// 
	// do the real assignment of triangles to child nodes:
	// 

	int smallerSide = (bestAreaLeft <= bestAreaRight)?0:1;
	for (TriangleIndexListIterator j = trilist->begin(); j != trilist->end(); ++j) {			

		// special case: triangle is coplanar to split plane.
		//  - if split plane is also a side of the AABB, put the tri into respective side
		//  - otherwise: put to smaller side (in terms of area)
		if (minvals[*j].e[bestAxis] == maxvals[*j].e[bestAxis]) {
			float v = minvals[*j].e[bestAxis];
			if (v == min.e[bestAxis]) {
				newlists[0]->push_back(*j);			
				continue;
			} 
			else if (v == max.e[bestAxis]) {
				newlists[1]->push_back(*j);
				continue;
			}
			else if (v == node.splitcoord) {
				newlists[smallerSide]->push_back(*j);
				continue;
			}
		}

		// non-collinear triangle, put in respective child or
		// both if overlapping
		if (minvals[*j].e[bestAxis] >= node.splitcoord) 
			newlists[1]->push_back(*j);
		else if (maxvals[*j].e[bestAxis] <= node.splitcoord) 
			newlists[0]->push_back(*j);
		else {
			newlists[0]->push_back(*j);
			newlists[1]->push_back(*j);
		}

	}

	newCount[0] = (unsigned int)newlists[0]->size();
	newCount[1] = (unsigned int)newlists[1]->size();	

	//if (newCount[0] != bestNumLeft || newCount[1] != bestNumRight) {
	/*if (debug2) {
	cout << "Counts inequal: Split:" << bestSplitCoord << " (N:" << triCount << " L:" << newCount[0] << " R:" << newCount[1] << ")" << endl;
	cout << "  should be : (L:" << bestNumLeft << " R:" << bestNumRight << ")" << endl;		


	renderSplit(axis, bestSplitCoord, min, max, newlists);
	}*/


	depth++;

	for (i = 0; i < 2; i++) { 
		bool was_subdivided = false;
		long thisChildFileOffset = curOffset + i*sizeof(BSPArrayTreeNode);

		// should we subdivide child further ?
		if (newCount[i] > (unsigned int)treeStats.maxListLength && depth < treeStats.maxDepth && (newCount[0] + newCount[1] < 2*triCount)) {
			if (debug1)
				cout << " ----> subdivide child " << i << endl;
			// build new min/max bounding box (if i=0, then [min...splitcoord], otherwise [splitcoord...max]:
			newmin.e[bestAxis] = (i==0)?min.e[bestAxis]:node.splitcoord;
			newmax.e[bestAxis] = (i==0)?node.splitcoord:max.e[bestAxis];
			dim = newmax - newmin;

			// recursively subdivide further along largest axis
			if (SubdivideSAH(thisChildFileOffset, newlists[i], depth, newmin, newmax, indexFP, nodeFP))
				was_subdivided = true;
		}

		if (!was_subdivided) { // make this child a leaf
			BSPArrayTreeNode newLeaf;
			unsigned int count = (unsigned int)newlists[i]->size();
			newLeaf.indexCount = MAKECHILDCOUNT(count);
			newLeaf.indexOffset = curIndex;
			curIndex += count;

			//if (depth > 20 && count > 20)
			//	cout << " ----> make leaf " << i << " (" << count << " tris, depth " << depth << ")" << endl;

			// write final node information to file:
			long tempPos = ftell(nodeFP);
			fseek(nodeFP, thisChildFileOffset, SEEK_SET);
			fwrite(&newLeaf, sizeof(BSPArrayTreeNode), 1, nodeFP);
			fseek(nodeFP, tempPos, SEEK_SET);

			// get real (global) triangle indices
			for (unsigned int cI = 0; cI < count; cI++)
				(*(newlists[i]))[cI] = triIndexList[(*(newlists[i]))[cI]];


			if (count != 0)
				// write index vector to file:
				fwrite(& (*(newlists[i]))[0], sizeof(int), count, indexFP);

			// statistical information:
			treeStats.numLeafs++;
			treeStats.sumDepth += depth;
			treeStats.sumTris  += count;
			if (depth > treeStats.maxLeafDepth)
				treeStats.maxLeafDepth = depth;
			if (count > treeStats.maxTriCountPerLeaf)
				treeStats.maxTriCountPerLeaf = count;
		}
	}

	return true;
}




void kDTree::renderSplit(int axisNr, float splitCoord, Vector3 min, Vector3 max,TriangleIndexList *newlists[2]) {	
#if 0
	glMatrixMode( GL_PROJECTION );
	glLoadIdentity();
	glFrustum(-1,1, -1,1, 2, 4000 );
	glMatrixMode( GL_MODELVIEW );

	cout << "Render Split at: " << splitCoord << " Axis " << axisNr << " left: " << newlists[0]->size() << " right: " << newlists[1]->size() << endl;

	glLoadIdentity();

	// Position		
	Ray viewer;
	float exVScale = 0.8f;
	Vector3 exVecScale =  exVScale*(this->max - this->min);
	Vector3 viewPos = Vector3(this->min[0] - exVecScale[0], this->max[1] - exVecScale[1], this->max[2] + exVecScale[2]);
	Vector3 viewDir = ((this->max + this->min)/2.0f + Vector3(0, 0, 0)) - viewPos;		

	viewer.setOrigin(viewPos);
	viewer.setDirection(viewDir);

	//;
	//viewer.setOrigin(Vector3(310.40,223.50,-153.20));
	//viewer.setDirection(Vector3(-0.83,-0.39,0.41));
	Vector3 lookAt = viewer.origin() + viewer.direction();	
	gluLookAt(viewer.origin().x(), viewer.origin().y(), viewer.origin().z(),  
		lookAt.x(), lookAt.y(), lookAt.z(), 
		0, 1, 0);

	// clear image
	glClearColor(0,0,0,1);
	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

	// set OpenGL state
	glDisable(GL_DEPTH_TEST);		
	glDisable(GL_TEXTURE_2D);	
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glEnable(GL_BLEND);	

	glColor4f(0.0f, 1.0f, 0.0, 1.0);
	if (axisNr == 0) {
		glBegin(GL_LINE_LOOP);
		glVertex3f(splitCoord, min[1], min[2]);
		glVertex3f(splitCoord, max[1], min[2]);
		glVertex3f(splitCoord, max[1], max[2]);
		glVertex3f(splitCoord, min[1], max[2]);
		glEnd();
	}
	else if (axisNr == 1) {
		glBegin(GL_LINE_LOOP);
		glVertex3f(min[0], splitCoord, min[2]);
		glVertex3f(max[0], splitCoord, min[2]);
		glVertex3f(max[0], splitCoord, max[2]);
		glVertex3f(min[0], splitCoord, max[2]);
		glEnd();
	}
	else if (axisNr == 2) {
		glBegin(GL_LINE_LOOP);
		glVertex3f(min[0], min[1], splitCoord);
		glVertex3f(max[0], min[1], splitCoord);
		glVertex3f(max[0], max[1], splitCoord);
		glVertex3f(min[0], max[1], splitCoord);
		glEnd();
	}

	glColor4f(0.0f, 1.0f, 0.0, 0.6f);
	glBegin(GL_LINE_LOOP); // bottom rectangle
	glVertex3f(min[0], min[1], min[2]);
	glVertex3f(max[0], min[1], min[2]);
	glVertex3f(max[0], min[1], max[2]);
	glVertex3f(min[0], min[1], max[2]);
	glEnd();

	glBegin(GL_LINE_LOOP); // top rectangle
	glVertex3f(min[0], max[1], min[2]);
	glVertex3f(max[0], max[1], min[2]);
	glVertex3f(max[0], max[1], max[2]);
	glVertex3f(min[0], max[1], max[2]);
	glEnd();

	glBegin(GL_LINES); // sides
	glVertex3f(min[0], min[1], min[2]);
	glVertex3f(min[0], max[1], min[2]);

	glVertex3f(max[0], min[1], min[2]);
	glVertex3f(max[0], max[1], min[2]);

	glVertex3f(min[0], min[1], max[2]);
	glVertex3f(min[0], max[1], max[2]);

	glVertex3f(max[0], min[1], max[2]);
	glVertex3f(max[0], max[1], max[2]);	
	glEnd();



	for (int curList = 0; curList < 2; curList++) {
		// wire color
		glColor4f(1.0f * curList, 0.0, 1.0f * (1-curList), 0.5);

		for (unsigned int i = 0; i < newlists[curList]->size(); i++) {
			/*Triangle &t = trianglelist[newlists[curList]->at(i)];

			glBegin(GL_LINE_LOOP);
			glVertex3fv(t.p[0]->e);
			glVertex3fv(t.p[1]->e);
			glVertex3fv(t.p[2]->e);			
			glEnd();
			*/
		}
	}

	/*
	glutSwapBuffers();	
	*/

	getchar();

	// restore state
	glDisable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);	
	glEnable(GL_TEXTURE_2D);
#endif
}

bool kDTree::saveToFile(const char* filename) {	
	LogManager *log = LogManager::getSingletonPtr();	
	char output[255];
	size_t ret;
	FILE *fp = fopen(filename, "wb");

	if (fp == NULL) {
		sprintf(output, "Could not open BSP tree file '%s'!", filename);
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	sprintf(output, "Saving BSP tree to file '%s'...", filename);
	log->logMessage(LOG_INFO, output);

	// write header and version:
	fwrite(BSP_FILEIDSTRING, 1, BSP_FILEIDSTRINGLEN, fp);
	fputc(BSP_FILEVERSION, fp);

	// write stats:
	fwrite(&treeStats, sizeof(BSPTreeInfo), 1, fp);

	// write tree node array:
	sprintf(output, "  ... writing %d tree nodes ...", treeStats.numNodes);
	log->logMessage(LOG_INFO, output);
	ret = fwrite(tree, sizeof(BSPArrayTreeNode), treeStats.numNodes, fp);

	if (ret != treeStats.numNodes) {
		sprintf(output, "Could only write %u nodes, expecting %u!", ret, treeStats.numNodes);
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	// write tri index array
	sprintf(output, "  ... writing %d tri indices ...", treeStats.sumTris);
	log->logMessage(LOG_INFO, output);
	ret = fwrite(indexlists, sizeof(unsigned int), treeStats.sumTris, fp);

	if (ret != treeStats.sumTris) {
		sprintf(output, "Could only write %u indices, expecting %u!", ret, treeStats.sumTris);
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	sprintf(output, "  done!");
	log->logMessage(LOG_INFO, output);
	fclose(fp);

	return true;
}


bool kDTree::loadFromFile(const char* filename) {	
	LogManager *log = LogManager::getSingletonPtr();	
	char output[1000];
	char header[100];
	char bspfilestring[50];
	size_t ret;
	FILE *fp = fopen(filename, "rb");

	if (fp == NULL) {
		sprintf(output, "Could not open BSP tree file '%s'!", filename);
		log->logMessage(LOG_WARNING, output);
		return false;
	}

	sprintf(output, "Loading BSP tree from file '%s'...", filename);
	log->logMessage(LOG_INFO, output);

	ret = fread(header, 1, BSP_FILEIDSTRINGLEN + 1, fp);
	if (ret != (BSP_FILEIDSTRINGLEN + 1)) {
		sprintf(output, "Could not read header from BSP tree file '%s', aborting. (empty file?)", filename);
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	// test header format:
	strcpy(bspfilestring, BSP_FILEIDSTRING);
	for (unsigned int i = 0; i < BSP_FILEIDSTRINGLEN; i++)
		if (header[i] != bspfilestring[i]) {
			printf(output, "Invalid BSP tree header, aborting. (expected:'%c', found:'%c')", bspfilestring[i], header[i]);
			log->logMessage(LOG_ERROR, output);
			return false;		
		}

		// test file version:
		if (header[BSP_FILEIDSTRINGLEN] != BSP_FILEVERSION) {
			printf(output, "Wrong BSP tree file version (expected:%d, found:%d)", BSP_FILEVERSION, header[BSP_FILEIDSTRINGLEN]);
			log->logMessage(LOG_ERROR, output);
			return false;		
		}

		// format correct, read in full BSP tree info structure:

		// write count of nodes and tri indices:
		ret = fread(&treeStats, sizeof(BSPTreeInfo), 1, fp);
		if (ret != 1) {
			sprintf(output, "Could not read tree info header!");
			log->logMessage(LOG_ERROR, output);
			return false;
		}

		sprintf(output, "Allocating memory...");
		//log->logMessage(LOG_INFO, output);

		tree = new BSPArrayTreeNode[treeStats.numNodes];	
		indexlists = new int[treeStats.sumTris];

		// write tree node array:
		sprintf(output, "  ... reading %d tree nodes ...", treeStats.numNodes);
		//log->logMessage(LOG_INFO, output);
		ret = fread(tree, sizeof(BSPArrayTreeNode), treeStats.numNodes, fp);

		if (ret != treeStats.numNodes) {
			sprintf(output, "Could only read %u nodes, expecting %u!", ret, treeStats.numNodes);
			log->logMessage(LOG_ERROR, output);
			return false;
		}

		// write tri index array
		sprintf(output, "  ... reading %d tri indices ...", treeStats.sumTris);
		//log->logMessage(LOG_INFO, output);
		ret = fread(indexlists, sizeof(int), treeStats.sumTris, fp);

		if (ret != treeStats.sumTris) {
			sprintf(output, "Could only read %u indices, expecting %u!", ret, treeStats.sumTris);
			log->logMessage(LOG_ERROR, output);
			return false;
		}

		sprintf(output, "  done!");
		//log->logMessage(LOG_INFO, output);
		fclose(fp);

		return true;
}	

bool kDTree::loadFromFiles(const char* filename) {	
	LogManager *log = LogManager::getSingletonPtr();	
	char filenameNodes[MAX_PATH], fileNameIndices[MAX_PATH];
	char output[1000];
	char header[100];
	char bspfilestring[50];
	size_t ret;

	sprintf(filenameNodes, "%s.node", filename);
	sprintf(fileNameIndices, "%s.idx", filename);

	FILE *fp = fopen(filename, "rb");
	FILE *fpNodes = fopen(filenameNodes, "rb");
	FILE *fpIndices = fopen(fileNameIndices, "rb");

	if (fp == NULL) {
		sprintf(output, "Could not open BSP tree file '%s'!", filename);
		log->logMessage(LOG_WARNING, output);
		return false;
	}

	if (fpNodes == NULL) {
		sprintf(output, "Could not open BSP tree file '%s'!", filenameNodes);
		log->logMessage(LOG_WARNING, output);
		fclose(fp);
		return false;
	}

	if (fpIndices == NULL) {
		sprintf(output, "Could not open BSP tree file '%s'!", fileNameIndices);
		log->logMessage(LOG_WARNING, output);
		fclose(fp);
		fclose(fpNodes);
		return false;
	}

	sprintf(output, "Loading BSP tree from files ('%s')...", filename);
	log->logMessage(LOG_INFO, output);

	ret = fread(header, 1, BSP_FILEIDSTRINGLEN + 1, fp);
	if (ret != (BSP_FILEIDSTRINGLEN + 1)) {
		sprintf(output, "Could not read header from BSP tree file '%s', aborting. (empty file?)", filename);
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	// test header format:
	strcpy(bspfilestring, BSP_FILEIDSTRING);
	for (unsigned int i = 0; i < BSP_FILEIDSTRINGLEN; i++) {
		if (header[i] != bspfilestring[i]) {
			printf(output, "Invalid BSP tree header, aborting. (expected:'%c', found:'%c')", bspfilestring[i], header[i]);
			log->logMessage(LOG_ERROR, output);
			return false;		
		}
	}

	// test file version:
	if (header[BSP_FILEIDSTRINGLEN] != BSP_FILEVERSION) {
		printf(output, "Wrong BSP tree file version (expected:%d, found:%d)", BSP_FILEVERSION, header[BSP_FILEIDSTRINGLEN]);
		log->logMessage(LOG_ERROR, output);
		return false;		
	}

	// format correct, read in full BSP tree info structure:

	// write count of nodes and tri indices:
	ret = fread(&treeStats, sizeof(BSPTreeInfo), 1, fp);
	if (ret != 1) {
		sprintf(output, "Could not read tree info header!");
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	sprintf(output, "Allocating memory...");
	log->logMessage(LOG_INFO, output);

	tree = new BSPArrayTreeNode[treeStats.numNodes];	
	indexlists = new int[treeStats.sumTris];

	// write tree node array:
	sprintf(output, "  ... reading %d tree nodes ...", treeStats.numNodes);
	log->logMessage(LOG_INFO, output);
	ret = fread(tree, sizeof(BSPArrayTreeNode), treeStats.numNodes, fpNodes);

	if (ret != treeStats.numNodes) {
		sprintf(output, "Could only read %u nodes, expecting %u!", ret, treeStats.numNodes);
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	// write tri index array
	sprintf(output, "  ... reading %d tri indices ...", treeStats.sumTris);
	log->logMessage(LOG_INFO, output);
	ret = fread(indexlists, sizeof(int), treeStats.sumTris, fpIndices);

	if (ret != treeStats.sumTris) {
		sprintf(output, "Could only read %u indices, expecting %u!", ret, treeStats.sumTris);
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	sprintf(output, "  done!");
	log->logMessage(LOG_INFO, output);
	fclose(fp);
	fclose(fpNodes);
	fclose(fpIndices);

	return true;
}	

void kDTree::printNodeInArray(const char *LoggerName, BSPArrayTreeNodePtr current, int depth) {

	LogManager *log = LogManager::getSingletonPtr();
	char outStr[500];
	char indent[100];
	char *axis = "XYZL";
	int axisNr;
	int numTris = 0;
	BSPArrayTreeNodePtr child_left, child_right;

	indent[0] = 0;
	if (depth > 0) {
		int i;
		for (i = 0; i < (depth-1)*2; i++) {
			indent[i]   = ' ';			
		}
		indent[i]   = '|';
		indent[i+1] = '-';		
		indent[depth*2] = 0;
	}
	else if (depth == 0) {
		if (tree == NULL)
			return;
		current = &tree[0];		
	}

	// find axis (encoded in the lower two bits)	
	axisNr = AXIS(current);
	child_left = GETNODE(GETLEFTCHILD(current));
	child_right = GETNODE(GETRIGHTCHILD(current));

	
	/*
	if (ISLEAF(current)) { // leaf		
		numTris = GETCHILDCOUNT(current);
		sprintf(outStr, "%sLeaf %d Tris", indent, numTris);
		log->logMessage(outStr, LoggerName);		
	}
	else {
		sprintf(outStr, "%sNode %c (%.2f) Children: %u/%u", indent, axis[axisNr], current->splitcoord, GETLEFTCHILD(current), GETRIGHTCHILD(current));
		log->logMessage(outStr, LoggerName);
	}*/

	if (ISNOLEAF(current)) {
		printNodeInArray(LoggerName, child_left, depth + 1);		
		printNodeInArray(LoggerName, child_right, depth + 1);
	}

}

void kDTree::printTree(bool dumpTree, const char *LoggerName) {
	LogManager *log = LogManager::getSingletonPtr();
	char outputBuffer[2000];
	log->logMessage("-------------------------------------------", LoggerName);
	log->logMessage("BSP Tree Statistics", LoggerName);
	log->logMessage("-------------------------------------------", LoggerName);
	sprintf(outputBuffer, "Time to build:\t%d seconds, %d milliseconds", (int)treeStats.timeBuild, (int)((treeStats.timeBuild - floor(treeStats.timeBuild)) * 1000));
	log->logMessage(outputBuffer, LoggerName);
	sprintf(outputBuffer, "Triangles:\t%d", treeStats.numTris);
	log->logMessage(outputBuffer, LoggerName);
	sprintf(outputBuffer, "Nodes:\t\t%d", treeStats.numNodes);
	log->logMessage(outputBuffer, LoggerName);
	sprintf(outputBuffer, "Leafs:\t\t%d", treeStats.numLeafs);
	log->logMessage(outputBuffer, LoggerName);
	sprintf(outputBuffer, "Max. leaf depth:\t%d (of %d)", treeStats.maxLeafDepth, treeStats.maxDepth);
	log->logMessage(outputBuffer, LoggerName);
	sprintf(outputBuffer, "Max. tri count/leaf:\t%d", treeStats.maxTriCountPerLeaf);
	log->logMessage(outputBuffer, LoggerName);
	if (treeStats.numLeafs > 0) {
		sprintf(outputBuffer, "Avg. leaf depth:\t%.2f", (float)treeStats.sumDepth / (float)treeStats.numLeafs);
		log->logMessage(outputBuffer, LoggerName);

		sprintf(outputBuffer, "Avg. tris/leaf:\t%.2f", (float)treeStats.sumTris / (float)treeStats.numLeafs);
		log->logMessage(outputBuffer, LoggerName);

		sprintf(outputBuffer, "Tri refs total:\t\t%d", treeStats.sumTris);
		log->logMessage(outputBuffer, LoggerName);

	}
	sprintf(outputBuffer, "Used memory:\t%d KB", (treeStats.numNodes*sizeof(BSPArrayTreeNode) + (treeStats.sumTris * sizeof(int))) / 1024);
	log->logMessage(outputBuffer, LoggerName);

	
	if (dumpTree) {		
		log->logMessage("-------------------------------------------", LoggerName);
		log->logMessage("BSP Tree structure", LoggerName);
		log->logMessage("-------------------------------------------", LoggerName);		
		printNodeInArray(LoggerName, NULL, 0);
		log->logMessage("-------------------------------------------", LoggerName);		
	}
}
int kDTree::getNumTris() {
	return treeStats.numTris;
}