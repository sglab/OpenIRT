#include <windows.h>
#include <gl/gl.h>
#include <gl/glu.h>
//#include <gl/glut.h>


#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <algorithm>

#include "BVH.h"
#if HIERARCHY_TYPE == TYPE_BVH 

// easy macros for working with the compressed BSP tree
// structure that is a bit hard to understand otherwise
// (and access may vary on whether OOC mode is on or not)

#if COMMON_COMPILER == COMPILER_MSVC
// disable portability warnings generated by 
// pointer arithmetic in code
#pragma warning( disable : 4311 4312 4102 )
#endif 

// surface area of a voxel:
__inline float surfaceArea(float dim1, float dim2, float dim3) {
	return 2.0f * ((dim1 * dim2) + (dim2 * dim3) + (dim1 * dim3));
}

#if 0
void BVH::buildTree()
{				
	BSPArrayTreeNode root;
	char tempindexName[MAX_PATH], tempnodesName[MAX_PATH];

	timeBuildStart.set();
	curIndex = 0;

	subdivisionMode = BSP_SUBDIVISIONMODE_NORMAL;

	// Build list with all indices and list of intervals:	
	leftlist[0] = new TriangleIndexList(treeStats.numTris);
	leftlist[1] = new TriangleIndexList(treeStats.numTris);

	for (int i = 0; i < MAXBSPSIZE; i++)
		rightlist[i] = new TriangleIndexList();

	// open temporary file for the indices
	sprintf(tempindexName, "tempindex_%d.tmp", treeID);
	FILE *indexFP = fopen(tempindexName, "wb+");
	// .. and tree nodes
	sprintf(tempnodesName, "tempnodes_%d.tmp", treeID);
	FILE *nodeFP = fopen(tempnodesName, "wb+");

	if (!indexFP) {
		LogManager *log = LogManager::getSingletonPtr();
		log->logMessage(LOG_ERROR, "Unable to write index file tempindex.tmp!");
		return;
	}

	if (!nodeFP) {
		LogManager *log = LogManager::getSingletonPtr();
		log->logMessage(LOG_ERROR, "Unable to write node file tempnodes.tmp!");
		return;
	}

	treeStats.numNodes = 1;	

	// subdivision mode == SAH ? then prepare min/max lists
	// for the triangle coordinates..
	if (subdivisionMode == BSP_SUBDIVISIONMODE_NORMAL) {
		minvals = new Vector3[treeStats.numTris];
		maxvals = new Vector3[treeStats.numTris];

		for (int i = 0; i < treeStats.numTris; i++) {
			const Triangle &tri = trianglelist[i];
			

			(*leftlist[0])[i] = i;

			minvals[i].e[0] = min(GETVERTEX(tri.p[0]).e[0], 
				                  min(GETVERTEX(tri.p[1]).e[0], GETVERTEX(tri.p[2]).e[0]));
			minvals[i].e[1] = min(GETVERTEX(tri.p[0]).e[1], 
				                  min(GETVERTEX(tri.p[1]).e[1], GETVERTEX(tri.p[2]).e[1]));
			minvals[i].e[2] = min(GETVERTEX(tri.p[0]).e[2], 
								  min(GETVERTEX(tri.p[1]).e[2], GETVERTEX(tri.p[2]).e[2]));

			maxvals[i].e[0] = max(GETVERTEX(tri.p[0]).e[0], 
				max(GETVERTEX(tri.p[1]).e[0], GETVERTEX(tri.p[2]).e[0]));
			maxvals[i].e[1] = max(GETVERTEX(tri.p[0]).e[1], 
				max(GETVERTEX(tri.p[1]).e[1], GETVERTEX(tri.p[2]).e[1]));
			maxvals[i].e[2] = max(GETVERTEX(tri.p[0]).e[2], 
				max(GETVERTEX(tri.p[1]).e[2], GETVERTEX(tri.p[2]).e[2]));

			//for (int j = 0; j < 3; j++) {
			//	minvals[i].e[j] = min(tri.p[0]->e[j], min(tri.p[1]->e[j], tri.p[2]->e[j]));
			//	maxvals[i].e[j] = max(tri.p[0]->e[j], max(tri.p[1]->e[j], tri.p[2]->e[j]));
			//}
		}
	}
	else { // all other subdivision modes:
		for (int i = 0; i < treeStats.numTris; i++) {	
			(*leftlist[0])[i] = i;
		}
	}

	// Start subdividing, if we have got triangles
	if (treeStats.numTris > 0 && treeStats.maxDepth > 0) {	
		int idx = 0;
		int useAxis = 0;

		// use largest axis for first subdivision
		Vector3 dim = max - min;

		fseek(nodeFP, sizeof(BSPArrayTreeNode), SEEK_SET);

		if (subdivisionMode == BSP_SUBDIVISIONMODE_SIMPLE) // spatial median
			Subdivide(0, leftlist[0], 0, dim.indexOfMaxComponent(), min, max, indexFP, nodeFP);
		else if (subdivisionMode == BSP_SUBDIVISIONMODE_NORMAL) // Surface area heuristic
			SubdivideSAH(0, leftlist[0], 0, min, max, indexFP, nodeFP);		
	}
	else { // no triangles or depth limit == 0: make root
		
		unsigned int count = (unsigned int)leftlist[0]->size();

		#ifdef _USE_ONE_TRI_PER_LEAF
		root.triIndex = 3;
		#else
		root.indexCount = MAKECHILDCOUNT(count);
		root.indexOffset = 0;
		#endif
		
		fwrite(&root, sizeof(BSPArrayTreeNode), 1, nodeFP);


		// get real (global) triangle indices
		for (unsigned int cI = 0; cI < count; cI++)
			(*(leftlist[0]))[cI] = triIndexList[(*(leftlist[0]))[cI]];

		// write vector to file:
		fwrite(& (*(leftlist[0]))[0], sizeof(int), count, indexFP);
	}

	delete leftlist[0];
	delete leftlist[1];

	for (int k = 0; k < MAXBSPSIZE; k++)
		delete rightlist[k];

	if (subdivisionMode == BSP_SUBDIVISIONMODE_NORMAL) {
		delete[] minvals;
		delete[] maxvals;
		minvals = 0;
		maxvals = 0;
	}

	// read in temporary files
	makeFlatRepresentation(indexFP, nodeFP);

	// remove temporary files (may be huge)
	remove(tempnodesName);
	remove(tempindexName);

	timeBuildEnd.set();
	treeStats.timeBuild = timeBuildEnd - timeBuildStart;
}
#endif

void BVH::buildTree()
{
	treeStats.numNodes = 1;	

	progBuildTree = new Progression("Build Tree", treeStats.numTris, 100);

	timeBuildStart.set();
	curIndex = 0;

	// Start subdividing, if we have got triangles
	if (treeStats.numTris > 0 && treeStats.maxDepth > 0) {	
		// use largest axis for first subdivision
		Vector3 dim = max - min;
		//tree = (BSPArrayTreeNodePtr)_aligned_malloc(sizeof(BSPArrayTreeNode)*(treeStats.numTris*2 - 1), BVHNODE_BYTES);
		tree = (BSPArrayTreeNodePtr)malloc(sizeof(BSPArrayTreeNode)*(treeStats.numTris*2 - 1));
		indexlists = new int[treeStats.numTris];

		leftlist[0] = new TriangleIndexList(treeStats.numTris);
		for (int i = 0; i < treeStats.numTris; i++) {	
			(*leftlist[0])[i] = i;
		}
		//leftlist[1] = new TriangleIndexList(treeStats.numTris);
		//for (int i = 0; i < treeStats.numTris; i++) {	
		//	(*leftlist[1])[i] = i;
		//}
//		Subdivide(leftlist[0], leftlist[1], 0, treeStats.numTris-1);
		Subdivide(leftlist[0], 0, treeStats.numTris-1);

		delete leftlist[0];
		//delete leftlist[1];
	}
	else { // no triangles or depth limit == 0: make root

		tree = NULL;
	}

	timeBuildEnd.set();
	treeStats.timeBuild = timeBuildEnd - timeBuildStart;	
	delete 	progBuildTree;
}

void BVH::buildTreeSAH()
{
	treeStats.numNodes = 1;	

	progBuildTree = new Progression("Build Tree", treeStats.numTris, 100);

	timeBuildStart.set();
	curIndex = 0;

	/*
	minvals = new Vector3[treeStats.numTris];
	maxvals = new Vector3[treeStats.numTris];
	*/

	printf("Allocating triangle index list ... ");
	leftlist[0] = new TriangleIndexList(treeStats.numTris);
	if(leftlist[0])
		printf("done.\n");
	else
	{
		printf("Error! %I64d\n", sizeof(TriangleIndexList)*((__int64) treeStats.numTris));
	}

	for (int i = 0; i < treeStats.numTris; i++) 
	{
		const Triangle &tri = trianglelist[i];
		

		(*leftlist[0])[i] = i;

		/*
		minvals[i].e[0] = min(GETVERTEX(tri.p[0]).v.e[0], 
			                  min(GETVERTEX(tri.p[1]).v.e[0], GETVERTEX(tri.p[2]).v.e[0]));
		minvals[i].e[1] = min(GETVERTEX(tri.p[0]).v.e[1], 
			                  min(GETVERTEX(tri.p[1]).v.e[1], GETVERTEX(tri.p[2]).v.e[1]));
		minvals[i].e[2] = min(GETVERTEX(tri.p[0]).v.e[2], 
							  min(GETVERTEX(tri.p[1]).v.e[2], GETVERTEX(tri.p[2]).v.e[2]));

		maxvals[i].e[0] = max(GETVERTEX(tri.p[0]).v.e[0], 
			max(GETVERTEX(tri.p[1]).v.e[0], GETVERTEX(tri.p[2]).v.e[0]));
		maxvals[i].e[1] = max(GETVERTEX(tri.p[0]).v.e[1], 
			max(GETVERTEX(tri.p[1]).v.e[1], GETVERTEX(tri.p[2]).v.e[1]));
		maxvals[i].e[2] = max(GETVERTEX(tri.p[0]).v.e[2], 
			max(GETVERTEX(tri.p[1]).v.e[2], GETVERTEX(tri.p[2]).v.e[2]));
		*/
	}
	// Start subdividing, if we have got triangles
	if (treeStats.numTris > 0 && treeStats.maxDepth > 0) {	
		// use largest axis for first subdivision
		Vector3 dim = max - min;
		//tree = (BSPArrayTreeNodePtr)_aligned_malloc(sizeof(BSPArrayTreeNode)*(treeStats.numTris*2 - 1), BVHNODE_BYTES);

		printf("Allocating tree ... ");
		tree = new BSPArrayTreeNode[treeStats.numTris*2 - 1];
		if(tree)
			printf("done.\n");
		else
		{
			printf("Error! %I64d\n", sizeof(BSPArrayTreeNode)*((__int64) (treeStats.numTris*2 - 1)));
		}

		printf("Allocating index list ... ");
		indexlists = new int[treeStats.numTris];
		if(indexlists)
			printf("done.\n");
		else
		{
			printf("Error! %I64d\n", sizeof(int)*((__int64) treeStats.numTris));
		}

		for (int i = 0; i < treeStats.numTris; i++) {	
			(*leftlist[0])[i] = i;
		}
		//leftlist[1] = new TriangleIndexList(treeStats.numTris);
		//for (int i = 0; i < treeStats.numTris; i++) {	
		//	(*leftlist[1])[i] = i;
		//}
//		Subdivide(leftlist[0], leftlist[1], 0, treeStats.numTris-1);
		//Subdivide(leftlist[0], 0, treeStats.numTris-1);
		
		
		BSPArrayTreeNodePtr root = tree;
		root->max = max;
		root->min = min;

		
		maxDEPTH = 0;

		SubdivideSAH(leftlist[0], 0, treeStats.numTris-1, 0, 1 , 0);

		printf("\n\nMAX DEPTH : %d\n",maxDEPTH);
		
//		getch();

		delete leftlist[0];
		//delete leftlist[1];
	}
	else { // no triangles or depth limit == 0: make root

		tree = NULL;
	}

	timeBuildEnd.set();
	treeStats.timeBuild = timeBuildEnd - timeBuildStart;
	if(curIndex != treeStats.numTris) printf("!!!!!!!!!!!!!!!!!!!!!!!!!!! %d\n", curIndex);

	delete progBuildTree;
}


void BVH::makeFlatRepresentation(FILE *indexFP, FILE *nodeFP) {
	LogManager *log = LogManager::getSingletonPtr();
	//log->logMessage(LOG_DEBUG, "Reading in array tree representation from file...");	

	// temporary node file:
	//log->logMessage(LOG_DEBUG, " - read in node list.");	
	tree = new BSPArrayTreeNode[treeStats.numNodes];
	fseek(nodeFP, 0, SEEK_SET);
	fread((void *)tree, sizeof(BSPArrayTreeNode), treeStats.numNodes, nodeFP);
	fclose(nodeFP);

	// temporary index list file:
	//log->logMessage(LOG_DEBUG, " - read in index list.");
	indexlists = new int[treeStats.sumTris];
	fseek(indexFP, 0, SEEK_SET);
	fread((void *)indexlists, sizeof(int), treeStats.sumTris, indexFP);
	fclose(indexFP);
}

void BVH::testWrite(BSPArrayTreeNodePtr curNode, BSPArrayTreeNodePtr parentNode)
{
	Vector3 diff = parentNode->max - parentNode->min;
	int biggestaxis = diff.indexOfMaxComponent();

	Vector3 pMin(parentNode->min);
	Vector3 pMax(parentNode->max);
	Vector3 cMin(curNode->min);
	Vector3 cMax(curNode->max);

	#if TEST_TYPE == 1
	fprintf(testFile, "%f\n", cMin.e[0]);
	fprintf(testFile, "%f\n", cMin.e[1]);
	fprintf(testFile, "%f\n", cMin.e[2]);
	fprintf(testFile, "%f\n", cMax.e[0]);
	fprintf(testFile, "%f\n", cMax.e[1]);
	fprintf(testFile, "%f\n", cMax.e[2]);
	#endif

	#if TEST_TYPE == 3
	int qValue = 256;
	pMin.e[0] = ((float)((int)(pMin.e[0]*256)))/256;
	pMin.e[1] = ((float)((int)(pMin.e[1]*256)))/256;
	pMin.e[2] = ((float)((int)(pMin.e[2]*256)))/256;
	pMax.e[0] = ((float)((int)(pMax.e[0]*256)))/256;
	pMax.e[1] = ((float)((int)(pMax.e[1]*256)))/256;
	pMax.e[2] = ((float)((int)(pMax.e[2]*256)))/256;
	cMin.e[0] = ((float)((int)(cMin.e[0]*256)))/256;
	cMin.e[1] = ((float)((int)(cMin.e[1]*256)))/256;
	cMin.e[2] = ((float)((int)(cMin.e[2]*256)))/256;
	cMax.e[0] = ((float)((int)(cMax.e[0]*256)))/256;
	cMax.e[1] = ((float)((int)(cMax.e[1]*256)))/256;
	cMax.e[2] = ((float)((int)(cMax.e[2]*256)))/256;
	#endif

	#if TEST_TYPE > 1
	bool isCase1 = false;
	for(int i=0;i<7;i++)
	{
		Vector3 pCn;
		Vector3 cCn;

		switch(i)
		{
		case 0:
			pCn.e[0] = pMin.e[0];
			pCn.e[1] = pMin.e[1];
			pCn.e[2] = pMin.e[2];
			cCn.e[0] = cMin.e[0];
			cCn.e[1] = cMin.e[1];
			cCn.e[2] = cMin.e[2];
			break;
		case 1:
			pCn.e[0] = pMax.e[0];
			pCn.e[1] = pMin.e[1];
			pCn.e[2] = pMin.e[2];
			cCn.e[0] = cMax.e[0];
			cCn.e[1] = cMin.e[1];
			cCn.e[2] = cMin.e[2];
			break;
		case 2:
			pCn.e[0] = pMin.e[0];
			pCn.e[1] = pMax.e[1];
			pCn.e[2] = pMin.e[2];
			cCn.e[0] = cMin.e[0];
			cCn.e[1] = cMax.e[1];
			cCn.e[2] = cMin.e[2];
			break;
		case 3:
			pCn.e[0] = pMax.e[0];
			pCn.e[1] = pMax.e[1];
			pCn.e[2] = pMin.e[2];
			cCn.e[0] = cMax.e[0];
			cCn.e[1] = cMax.e[1];
			cCn.e[2] = cMin.e[2];
			break;
		case 4:
			pCn.e[0] = pMin.e[0];
			pCn.e[1] = pMin.e[1];
			pCn.e[2] = pMax.e[2];
			cCn.e[0] = cMin.e[0];
			cCn.e[1] = cMin.e[1];
			cCn.e[2] = cMax.e[2];
			break;
		case 5:
			pCn.e[0] = pMax.e[0];
			pCn.e[1] = pMin.e[1];
			pCn.e[2] = pMax.e[2];
			cCn.e[0] = cMax.e[0];
			cCn.e[1] = cMin.e[1];
			cCn.e[2] = cMax.e[2];
			break;
		case 6:
			pCn.e[0] = pMin.e[0];
			pCn.e[1] = pMax.e[1];
			pCn.e[2] = pMax.e[2];
			cCn.e[0] = cMin.e[0];
			cCn.e[1] = cMax.e[1];
			cCn.e[2] = cMax.e[2];
			break;
		case 7:
			pCn.e[0] = pMax.e[0];
			pCn.e[1] = pMax.e[1];
			pCn.e[2] = pMax.e[2];
			cCn.e[0] = cMax.e[0];
			cCn.e[1] = cMax.e[1];
			cCn.e[2] = cMax.e[2];
			break;
		}

		if(pCn == cCn)
		{
			Vector3 cDiff = cMax - cMin;
			#if TEST_TYPE <= 3
			fprintf(testFile, "%f\n", cDiff.e[0]/diff.e[0]);
			fprintf(testFile, "%f\n", cDiff.e[1]/diff.e[1]);
			fprintf(testFile, "%f\n", cDiff.e[2]/diff.e[2]);
			#endif
			#if TEST_TYPE == 4
			fprintf(testFile, "%f\n", cDiff.e[biggestaxis]/diff.e[biggestaxis]);
			#endif
			#if TEST_TYPE == 5
			int axis1, axis2;
			switch(biggestaxis)
			{
			case 0 : axis1 = 1, axis2 = 2; break;
			case 1 : axis1 = 0, axis2 = 2; break;
			case 2 : axis1 = 0, axis2 = 1; break;
			}
			fprintf(testFile, "%f\n", cDiff.e[axis1]/diff.e[axis1]);
			fprintf(testFile, "%f\n", cDiff.e[axis2]/diff.e[axis2]);
			#endif
			#if TEST_TYPE == 6
			int axis1, axis2;
			switch(biggestaxis)
			{
			case 0 : axis1 = 1, axis2 = 2; break;
			case 1 : axis1 = 0, axis2 = 2; break;
			case 2 : axis1 = 0, axis2 = 1; break;
			}
			fprintf(testFile, "%f\n", .5 * diff[biggestaxis] - cDiff.e[biggestaxis]);
			fprintf(testFile, "%f\n", diff.e[axis1] - cDiff.e[axis1]);
			fprintf(testFile, "%f\n", diff.e[axis2] - cDiff.e[axis2]);
			#endif
			isCase1 = true;
			break;
		}
	}
	#if TEST_TYPE == 7
	if(isCase1)
		numCase1++;
	else
		numCase2++;
	#endif
	#endif
}

bool BVH::Subdivide(TriangleIndexList *triIDs, unsigned int left, unsigned int right, unsigned int myIndex, unsigned int nextIndex, int depth)
{
	BSPArrayTreeNodePtr node = (BSPArrayTreeNodePtr)((char *)tree + ((((__int64)myIndex) * BVHNODE_BYTES)) );

	// find biggest axis:
	Vector3 diff = max - min;
	if(myIndex != 0) diff = node->max - node->min;
	int biggestaxis = diff.indexOfMaxComponent();
	float split_pt = .5 * diff[biggestaxis] +min[biggestaxis];
	if(myIndex != 0) split_pt = .5 * diff[biggestaxis] + node->min[biggestaxis];
	else {node->min = min; node->max = max;}

	// compute average primitive location:
	int tsz = right - left + 1;
	float avgloc;
	unsigned int curLeft = left, 
		         curRight = right;
	for (int count = 0; count < tsz; count++) {
		const Triangle &tri = GETTRI(triIDs->at(curLeft));

		avgloc = GETVERTEX(tri.p[0]).v.e[biggestaxis]; 
		avgloc += GETVERTEX(tri.p[1]).v.e[biggestaxis]; 
		avgloc += GETVERTEX(tri.p[2]).v.e[biggestaxis]; 
		avgloc *=.33333333334;

		if (avgloc < split_pt) {
			curLeft++;
		} else { // swap with last unprocessed element
			unsigned int temp = triIDs->at(curLeft);
			triIDs->at(curLeft) = triIDs->at(curRight);
			triIDs->at(curRight) = temp;			

			curRight--;
		}
	}	

	unsigned int numLeft = curLeft - left;
	
	// special case: subdivision did not work out, just go half/half
	if (numLeft == 0 || numLeft == tsz) {
		numLeft = tsz/2;		
	}
	
	unsigned int lChildIdx = curNodeIdx;
	unsigned int rChildIdx = curNodeIdx+1;
	node->children = ((curNodeIdx) * (BVHNODE_BYTES >> 3)) | biggestaxis;
	#ifndef _USE_CONTI_NODE
	node->children2 = ((curNodeIdx+1) * (BVHNODE_BYTES >> 3));
	#else
	node->children2 = 0;
	#endif
	curNodeIdx += 2;

	treeStats.numNodes += 2;

	float BB_min_limit[3] = {FLT_MAX, FLT_MAX, FLT_MAX};
	float BB_max_limit[3] = {-FLT_MAX, -FLT_MAX, -FLT_MAX};

	BSPArrayTreeNodePtr lChild = (BSPArrayTreeNodePtr)((char *)tree + GETLEFTCHILD(node));
	BSPArrayTreeNodePtr rChild = (BSPArrayTreeNodePtr)((char *)tree + GETRIGHTCHILD(node));
	// only one triangle left, make this a leaf:
	if (numLeft <= maxNumTrisPerLeaf) {
		unsigned int count = numLeft;
		#ifdef _USE_ONE_TRI_PER_LEAF
		lChild->triIndex = (curIndex << 2) | 3;
		#else
		lChild->indexCount = MAKECHILDCOUNT(count);
		// !@#$
		lChild->indexOffset = curIndex;//triIDs->at(left);
		#endif
		const Triangle &tri = GETTRI(triIDs->at(left));

//		setBB(lChild->min, lChild->max, GETVERTEX(tri.p[0]));
//		updateBB(lChild->min, lChild->max, GETVERTEX(tri.p[1]));
//		updateBB(lChild->min, lChild->max, GETVERTEX(tri.p[2]));

//		testWrite(lChild, node);

		{
			treeStats.numLeafs++;
			treeStats.sumDepth += depth;
			treeStats.sumTris += count;
			// get real (global) triangle indice
			lChild->min.set(BB_min_limit);
			lChild->max.set(BB_max_limit);
			for(int i=0;i<count;i++)
			{
				const Triangle &tri = GETTRI(triIDs->at(left+i));
				updateBB(lChild->min, lChild->max, GETVERTEX(tri.p[0]).v);
				updateBB(lChild->min, lChild->max, GETVERTEX(tri.p[1]).v);
				updateBB(lChild->min, lChild->max, GETVERTEX(tri.p[2]).v);	
				indexlists[curIndex++] = triIndexList[triIDs->at(left+i)];
				progBuildTree->step();
			}
		}
		//curNodeIdx++;
	}	
	else { 
		lChild->min.set(BB_min_limit);
		lChild->max.set(BB_max_limit);
		for (unsigned int index = left; index <= (left+numLeft-1); index++) {
			const Triangle &tri = GETTRI(triIDs->at(index));
			updateBB(lChild->min, lChild->max, GETVERTEX(tri.p[0]).v);
			updateBB(lChild->min, lChild->max, GETVERTEX(tri.p[1]).v);
			updateBB(lChild->min, lChild->max, GETVERTEX(tri.p[2]).v);
		}
		
//		testWrite(lChild, node);

		Subdivide(triIDs, left, left+numLeft-1, lChildIdx, nextIndex + 2, depth + 1);
	}

	// only one triangle left, make this a leaf:
	if ((tsz - numLeft) <= maxNumTrisPerLeaf) {
		unsigned int count = tsz - numLeft;
		#ifdef _USE_ONE_TRI_PER_LEAF
		rChild->triIndex = (curIndex << 2) | 3;
		#else
		rChild->indexCount = MAKECHILDCOUNT(count);
		rChild->indexOffset = curIndex;
		#endif
		const Triangle &tri = GETTRI(triIDs->at(left+numLeft));	

//		testWrite(rChild, node);

		{
			treeStats.numLeafs++;
			treeStats.sumDepth += depth;
			treeStats.sumTris += count;
			// get real (global) triangle indices
			rChild->min.set(BB_min_limit);
			rChild->max.set(BB_max_limit);
			for(int i=0;i<count;i++)
			{
				const Triangle &tri = GETTRI(triIDs->at(left+numLeft+i));
				updateBB(rChild->min, rChild->max, GETVERTEX(tri.p[0]).v);
				updateBB(rChild->min, rChild->max, GETVERTEX(tri.p[1]).v);
				updateBB(rChild->min, rChild->max, GETVERTEX(tri.p[2]).v);	
				indexlists[curIndex++] = triIndexList[triIDs->at(left+numLeft+i)];
				progBuildTree->step();
			}
		}
		//curNodeIdx++;
	}	
	else { 
		rChild->min.set(BB_min_limit);
		rChild->max.set(BB_max_limit);
		for (unsigned int index = left+numLeft; index <= right; index++) {
			const Triangle &tri = GETTRI(triIDs->at(index));

			updateBB(rChild->min, rChild->max, GETVERTEX(tri.p[0]).v);
			updateBB(rChild->min, rChild->max, GETVERTEX(tri.p[1]).v);
			updateBB(rChild->min, rChild->max, GETVERTEX(tri.p[2]).v);
		}
		
//		testWrite(rChild, node);

		Subdivide(triIDs, left+numLeft, right, rChildIdx, nextIndex + curNodeIdx, depth + 1);//nextIndex + 2*numLeft);
	}
	return true;
}

#include "conio.h"
bool BVH::SubdivideSAHSingle(TriangleIndexList *triIDs, unsigned int left, unsigned int right, unsigned int myIndex, unsigned int nextIndex, int depth)
{
	if( depth > maxDEPTH )
	{
		maxDEPTH = depth;
	}

	BSPArrayTreeNodePtr lChild = (BSPArrayTreeNodePtr)((char *)tree + ((((__int64)(nextIndex)) * BVHNODE_BYTES) << 0) );
	BSPArrayTreeNodePtr rChild = (BSPArrayTreeNodePtr)((char *)tree + ((((__int64)(nextIndex + 1)) * BVHNODE_BYTES) << 0) );
	BSPArrayTreeNodePtr node = (BSPArrayTreeNodePtr)((char *)tree + (((__int64)myIndex) * BVHNODE_BYTES) );

	/*
	BSPArrayTreeNodePtr lChild = (BSPArrayTreeNodePtr)((char *)tree + ((unsigned int)(((nextIndex) * BVHNODE_BYTES) << 0) & ~3) );
	BSPArrayTreeNodePtr rChild = (BSPArrayTreeNodePtr)((char *)tree + ((unsigned int)(((nextIndex + 1) * BVHNODE_BYTES) << 0) & ~3) );
	BSPArrayTreeNodePtr node = (BSPArrayTreeNodePtr)((char *)tree + ((unsigned int)(myIndex * BVHNODE_BYTES) & ~3) );
	*/

	if(myIndex == 0)	// root node
	{
		node->min = this->min;
		node->max = this->max;
	}

	int bestAxis;
	int k, i, nE, temp, nL, nR, nT;
	float bestCoor, bestVal, val, curL, curR;
	float SA, *SL, *SR;
	FeelEvent *events;
	Vector3 p1, p2;
		
	nT = right - left + 1;
	events =new FeelEvent[ nT + 2 ];
	nE = nT;
	SL = new float[ nE + 2 ];
	SR = new float[ nE + 2 ];
	
	bestAxis = -1;
	bestVal = FLT_MAX;

	SA = surfaceArea( node->max[0] - node->min[0] , node->max[1] - node->min[1] , node->max[2] - node->min[2] );

	bool isSAzero = ( fabs( SA - 0.0f ) == 0.0f );
	if( isSAzero )
	{
		node->children = ((nextIndex) * (BVHNODE_BYTES >> 3) ) | 0;
		#ifndef _USE_CONTI_NODE
		node->children2 = ((nextIndex+1) * (BVHNODE_BYTES >> 3) );
		#else
		node->children2 = 0;
		#endif

		treeStats.numNodes += 2;

		nL = nT / 2;
		nR = nT - nL;

		if( nL == 1 )
		{
			#ifdef _USE_ONE_TRI_PER_LEAF
			lChild->triIndex = (curIndex << 2) | 3;
			#else
			lChild->indexCount = MAKECHILDCOUNT(1);
			lChild->indexOffset = curIndex;
			#endif
			lChild->min = node->min;
			lChild->max = node->max;

			treeStats.numLeafs++;
			treeStats.sumDepth += depth;
			treeStats.sumTris++;
			progBuildTree->step();

			indexlists[ curIndex++ ] = triIndexList[ triIDs->at(left) ];
		}
		else
		{
			lChild->min = node->min;
			lChild->max = node->max;

			SubdivideSAH( triIDs , left , left + nL -1 , nextIndex , nextIndex + 2 , depth + 1 );
		}


		if( nR == 1 )
		{
			#ifdef _USE_CONTI_NODE
			rChild->triIndex = (curIndex << 2) | 3;
			#else
			rChild->indexCount = MAKECHILDCOUNT(1);
			rChild->indexOffset = curIndex;
			#endif
			rChild->min = node->min;
			rChild->max = node->max;
			treeStats.numLeafs++;
			treeStats.sumDepth += depth;
			treeStats.sumTris++;
			progBuildTree->step();

			indexlists[ curIndex++ ] = triIndexList[ triIDs->at( left + nL ) ];

		}
		else
		{
			rChild->min = node->min;
			rChild->max = node->max;

			SubdivideSAH( triIDs , left + nL , right , nextIndex + 1 , nextIndex + 2 * nL , depth+1);
		}
		return true;
	}

	for(k = 0 ; k <= 2 ; k++ )		// for all AXIS  0 : X   1 : Y    2 : Z
	{
		for(i=0;i<nE;i++)
		{
			const Triangle &tri = GETTRI( triIDs->at( left + i ) );
			events[ i ].coor = ( ( GETVERTEX( (tri.p[0]) ).v.e[ k ]  + GETVERTEX( (tri.p[1]) ).v.e[ k ] + GETVERTEX( (tri.p[2]) ).v.e[ k ] ) ) / 3.0;
			events[ i ].triIndex = left + i;
		}

		std::sort( &events[0] , &events[nE] );
		
		p1.e[0] = FLT_MAX;		p1.e[1] = FLT_MAX;		p1.e[2] = FLT_MAX;
		p2.e[0] = -FLT_MAX;		p2.e[1] = -FLT_MAX;		p2.e[2] = -FLT_MAX;
		for(i=0;i<nE;i++)
		{
			const Triangle &tri = GETTRI( triIDs->at( events[i].triIndex ) );
			
			updateBB( p1 , p2 , GETVERTEX( tri.p[0] ).v );
			updateBB( p1 , p2 , GETVERTEX( tri.p[1] ).v );
			updateBB( p1 , p2 , GETVERTEX( tri.p[2] ).v );
			
			SL[ i ] = surfaceArea( p2[0] - p1[0] , p2[1] - p1[1] , p2[2] - p1[2] );
		}

		p1.e[0] = FLT_MAX;		p1.e[1] = FLT_MAX;		p1.e[2] = FLT_MAX;
		p2.e[0] = -FLT_MAX;		p2.e[1] = -FLT_MAX;		p2.e[2] = -FLT_MAX;
		for(i=nE-1;i>=0;i--)
		{
			const Triangle &tri = GETTRI( triIDs->at( events[i].triIndex ) );

			updateBB( p1 , p2 , GETVERTEX( tri.p[0] ).v );
			updateBB( p1 , p2 , GETVERTEX( tri.p[1] ).v );
			updateBB( p1 , p2 , GETVERTEX( tri.p[2] ).v );

			SR[ i ] = surfaceArea( p2[0] - p1[0] , p2[1] - p1[1] , p2[2] - p1[2] );
		}

		for(i=0;i<=nE-1;i++)
		{
			val = SL[ i ]/ SA * ( (float)(i) ) + SR[ i ] / SA * ( (float)( nT - i ) );

			/*
			if( nT == 294 )
			{
				printf("L : %d  R : %d    SL/SA : %lf   SR/SA : %lf   val : %lf \n",i,nT-i,SL[i]/SA,SR[i]/SA,val);
				getch();
			}
			*/

			

			if( val < bestVal )
			{
				bestVal = val;
				bestAxis = k;
				bestCoor = events[i].coor;
			}
		}
	}

	delete [] events;
	delete [] SL;
	delete [] SR;

	curL = left;
	curR = right;

	for(i=0;i<nT;i++)
	{
		const Triangle &tri = GETTRI( triIDs->at( curL ) );
		val = ( ( GETVERTEX( (tri.p[0]) ).v.e[ bestAxis ]  + GETVERTEX( (tri.p[1]) ).v.e[ bestAxis ] + GETVERTEX( (tri.p[2]) ).v.e[ bestAxis ] ) ) / 3.0;
		if( val < bestCoor )
		{
			curL++;
		}
		else
		{
			temp = triIDs->at( curL );
			triIDs->at( curL ) = triIDs->at( curR );
			triIDs->at( curR ) = temp;
			curR--;
		}
	}

	nL = curL - left;
	nR = nT - nL;


	if( nL == 0 || nR == 0 )
	{
		nL = (nT+1) / 2;
		nR = nT - nL;
	}
	/*
	
	if( nL >= 5 * nR || 5 * nL <= nR )
	{
		printf("SKEW  L : %d   R : %d  \n",nL,nR);
		getch();
	}

	
	
	if( nT == 0 )
	{
		printf("\n *** ZERO *** \n");
		getch();
	}
	*/
	

	/*
	printf("\nnT : %d     L : %d    R : %d  VAL : %lf \n",right-left+1,nL,nR,bestVal);
	getch();
	*/

	node->children = ((nextIndex) * (BVHNODE_BYTES >> 3) ) | bestAxis;
	#ifndef _USE_CONTI_NODE
	node->children2 = ((nextIndex+1) * (BVHNODE_BYTES >> 3) );
	#else
	node->children2 = 0;
	#endif

	treeStats.numNodes += 2;

	if( nL == 1 )
	{
		#ifdef _USE_ONE_TRI_PER_LEAF
		lChild->triIndex = (curIndex << 2) | 3;
		#else
		lChild->indexCount = MAKECHILDCOUNT(1);
		lChild->indexOffset = curIndex;
		#endif

		const Triangle &tri = GETTRI( triIDs->at( left ) );

		setBB( lChild->min , lChild->max , GETVERTEX( tri.p[0] ).v );
		updateBB( lChild->min , lChild->max , GETVERTEX( tri.p[1] ).v );
		updateBB( lChild->min , lChild->max , GETVERTEX( tri.p[2] ).v );

		treeStats.numLeafs++;
		treeStats.sumDepth += depth;
		treeStats.sumTris++;
		progBuildTree->step();

		indexlists[ curIndex++ ] = triIndexList[ triIDs->at(left) ];
	}
	else
	{
		lChild->min.e[0] = FLT_MAX;			lChild->min.e[1] = FLT_MAX;			lChild->min.e[2] = FLT_MAX;		
		lChild->max.e[0] = -FLT_MAX;		lChild->max.e[1] = -FLT_MAX;		lChild->max.e[2] = -FLT_MAX;
		for(i=left;i<=(left+nL-1);i++)
		{
			const Triangle &tri = GETTRI( triIDs->at(i) );
			updateBB( lChild->min , lChild->max , GETVERTEX( tri.p[0] ).v );
			updateBB( lChild->min , lChild->max , GETVERTEX( tri.p[1] ).v );
			updateBB( lChild->min , lChild->max , GETVERTEX( tri.p[2] ).v );
		}

		SubdivideSAH( triIDs , left , left + nL -1 , nextIndex , nextIndex + 2 , depth + 1 );
	}

	if( nR == 1 )
	{
		#ifdef _USE_ONE_TRI_PER_LEAF
		rChild->triIndex = (curIndex << 2) | 3;
		#else
		rChild->indexCount = MAKECHILDCOUNT(1);
		rChild->indexOffset = curIndex;
		#endif

		const Triangle &tri = GETTRI( triIDs->at( left + nL ) );

		setBB( rChild->min , rChild->max , GETVERTEX( tri.p[0] ).v );
		updateBB( rChild->min , rChild->max , GETVERTEX( tri.p[1] ).v );
		updateBB( rChild->min , rChild->max , GETVERTEX( tri.p[2] ).v );

		treeStats.numLeafs++;
		treeStats.sumDepth += depth;
		treeStats.sumTris++;
		progBuildTree->step();
		indexlists[ curIndex++ ] = triIndexList[ triIDs->at( left + nL ) ];
	}
	else
	{
		rChild->min.e[0] = FLT_MAX;			rChild->min.e[1] = FLT_MAX;			rChild->min.e[2] = FLT_MAX;		
		rChild->max.e[0] = -FLT_MAX;		rChild->max.e[1] = -FLT_MAX;		rChild->max.e[2] = -FLT_MAX;
		for(i=left+nL;i<=right;i++)
		{
			const Triangle &tri = GETTRI( triIDs->at(i) );
			updateBB( rChild->min , rChild->max , GETVERTEX( tri.p[0] ).v );
			updateBB( rChild->min , rChild->max , GETVERTEX( tri.p[1] ).v );
			updateBB( rChild->min , rChild->max , GETVERTEX( tri.p[2] ).v );
		}

		SubdivideSAH( triIDs , left + nL , right , nextIndex + 1 , nextIndex + 2 * nL , depth+1);
	}

	

	return true;
}

bool BVH::SubdivideSAH(TriangleIndexList *triIDs, unsigned int left, unsigned int right, unsigned int myIndex, unsigned int nextIndex, int depth)
{
	if(myIndex > treeStats.numTris*2 - 1 || nextIndex + 1 > treeStats.numTris*2 - 1)
	{
		printf("Out of index! %d, %d\n", myIndex, nextIndex + 1);
		exit(-1);
	}
	if( depth > maxDEPTH )
	{
		maxDEPTH = depth;
	}

	BSPArrayTreeNodePtr lChild = (BSPArrayTreeNodePtr)((char *)tree + ((((__int64)(nextIndex)) * BVHNODE_BYTES) << 0) );
	BSPArrayTreeNodePtr rChild = (BSPArrayTreeNodePtr)((char *)tree + ((((__int64)(nextIndex + 1)) * BVHNODE_BYTES) << 0) );
	BSPArrayTreeNodePtr node = (BSPArrayTreeNodePtr)((char *)tree + (((__int64)myIndex) * BVHNODE_BYTES) );

	int bestAxis;
	int k, i, nE, temp, nL, nR, nT;
	float bestCoor, bestVal, val;
	unsigned int curL, curR;
	float SA, *SL, *SR;
	FeelEvent *events;
	Vector3 p1, p2;
		
	nT = right - left + 1;
	events =new FeelEvent[ nT + 2 ];
	nE = nT;
	SL = new float[ nE + 2 ];
	SR = new float[ nE + 2 ];
	
	bestAxis = 0;
	bestVal = FLT_MAX;
	const Triangle &tempTri = GETTRI( triIDs->at( left) );
	bestCoor = ( ( GETVERTEX( (tempTri.p[0]) ).v.e[ 0 ]  + GETVERTEX( (tempTri.p[1]) ).v.e[ 0 ] + GETVERTEX( (tempTri.p[2]) ).v.e[ 0 ] ) ) / 3.0;

	SA = surfaceArea( node->max[0] - node->min[0] , node->max[1] - node->min[1] , node->max[2] - node->min[2] );

	/*bool isSAzero = ( fabs( SA - 0.0f ) == 0.0f );
	if( isSAzero )
	{
		node->indexCount = MAKECHILDCOUNT(nT);
		node->indexOffset = curIndex;
		treeStats.numLeafs++;
		treeStats.sumDepth += depth;
		treeStats.sumTris += nT;
		for(int i=left;i<=right;i++)
			indexlists[curIndex++] = triIndexList[triIDs->at(i)];

		delete [] events;
		delete [] SL;
		delete [] SR;
		return true;
	}
	*/

	for(k = 0 ; k <= 2 ; k++ )		// for all AXIS  0 : X   1 : Y    2 : Z
	{
		for(i=0;i<nE;i++)
		{
			const Triangle &tri = GETTRI( triIDs->at( left + i ) );
			events[ i ].coor = ( ( GETVERTEX( (tri.p[0]) ).v.e[ k ]  + GETVERTEX( (tri.p[1]) ).v.e[ k ] + GETVERTEX( (tri.p[2]) ).v.e[ k ] ) ) / 3.0;
			events[ i ].triIndex = left + i;
		}

		std::sort( &events[0] , &events[nE] );

		
		p1.e[0] = FLT_MAX;		p1.e[1] = FLT_MAX;		p1.e[2] = FLT_MAX;
		p2.e[0] = -FLT_MAX;		p2.e[1] = -FLT_MAX;		p2.e[2] = -FLT_MAX;
		for(i=0;i<nE;i++)
		{
			const Triangle &tri = GETTRI( triIDs->at( events[i].triIndex ) );
			
			updateBB( p1 , p2 , GETVERTEX( tri.p[0] ).v );
			updateBB( p1 , p2 , GETVERTEX( tri.p[1] ).v );
			updateBB( p1 , p2 , GETVERTEX( tri.p[2] ).v );
			
			SL[ i ] = surfaceArea( p2[0] - p1[0] , p2[1] - p1[1] , p2[2] - p1[2] );
		}

		p1.e[0] = FLT_MAX;		p1.e[1] = FLT_MAX;		p1.e[2] = FLT_MAX;
		p2.e[0] = -FLT_MAX;		p2.e[1] = -FLT_MAX;		p2.e[2] = -FLT_MAX;
		for(i=nE-1;i>=0;i--)
		{
			const Triangle &tri = GETTRI( triIDs->at( events[i].triIndex ) );

			updateBB( p1 , p2 , GETVERTEX( tri.p[0] ).v );
			updateBB( p1 , p2 , GETVERTEX( tri.p[1] ).v );
			updateBB( p1 , p2 , GETVERTEX( tri.p[2] ).v );

			SR[ i ] = surfaceArea( p2[0] - p1[0] , p2[1] - p1[1] , p2[2] - p1[2] );
		}

		for(i=0;i<=nE-1;i++)
		{
			val = SL[ i ]/ SA * ( (float)(i) ) + SR[ i ] / SA * ( (float)( nT - i ) );

			/*
			if( nT == 294 )
			{
				printf("L : %d  R : %d    SL/SA : %lf   SR/SA : %lf   val : %lf \n",i,nT-i,SL[i]/SA,SR[i]/SA,val);
				getch();
			}
			*/

			

			if( val < bestVal )
			{
				bestVal = val;
				bestAxis = k;
				bestCoor = events[i].coor;
			}
		}
	}

	delete [] events;
	delete [] SL;
	delete [] SR;

	curL = left;
	curR = right;

	for(i=0;i<nT;i++)
	{
		const Triangle &tri = GETTRI( triIDs->at( curL ) );
		val = ( ( GETVERTEX( (tri.p[0]) ).v.e[ bestAxis ]  + GETVERTEX( (tri.p[1]) ).v.e[ bestAxis ] + GETVERTEX( (tri.p[2]) ).v.e[ bestAxis ] ) ) / 3.0;
		if( val < bestCoor )
		{
			curL++;
		}
		else
		{
			temp = triIDs->at( curL );
			triIDs->at( curL ) = triIDs->at( curR );
			triIDs->at( curR ) = temp;
			curR--;
		}
	}

	nL = curL - left;
	nR = nT - nL;

	/*
	if( nL == 0 || nR == 0 )
	{
		node->indexCount = MAKECHILDCOUNT(nT);
		node->indexOffset = curIndex;
		treeStats.numLeafs++;
		treeStats.sumDepth += depth;
		treeStats.sumTris += nT;
		for(int i=left;i<=right;i++)
			indexlists[curIndex++] = triIndexList[triIDs->at(i)];
		return true;
	}
	*/

	if( nL == 0 || nR == 0 )
	{
		nL = (nT+1) / 2;
		nR = nT - nL;
	}

	node->children = ((nextIndex) * (BVHNODE_BYTES >> 3) ) | bestAxis;
	#ifndef _USE_CONTI_NODE
	node->children2 = ((nextIndex+1) * (BVHNODE_BYTES >> 3) );
	#else
	node->children2 = 0;
	#endif

	treeStats.numNodes += 2;

	float BB_min_limit[3] = {FLT_MAX, FLT_MAX, FLT_MAX};
	float BB_max_limit[3] = {-FLT_MAX, -FLT_MAX, -FLT_MAX};

	lChild->min.set(BB_min_limit);
	lChild->max.set(BB_max_limit);
	for(int i=left;i<=(left+nL-1);i++)
	{
		const Triangle &tri = GETTRI( triIDs->at(i) );
		updateBB( lChild->min , lChild->max , GETVERTEX( tri.p[0] ).v );
		updateBB( lChild->min , lChild->max , GETVERTEX( tri.p[1] ).v );
		updateBB( lChild->min , lChild->max , GETVERTEX( tri.p[2] ).v );
	}

	if( nL <= maxNumTrisPerLeaf )
	{
		lChild->indexCount = MAKECHILDCOUNT(nL);
		lChild->indexOffset = curIndex;

		for(int i=left;i<=(left+nL-1);i++)
		{
			indexlists[curIndex++] = triIndexList[triIDs->at(i)];
			progBuildTree->step();
		}

		treeStats.numLeafs++;
		treeStats.sumDepth += depth;
		treeStats.sumTris += nL;
	}
	else
	{
		SubdivideSAH( triIDs , left , left + nL -1 , nextIndex , nextIndex + 2 , depth + 1 );
	}

	rChild->min.set(BB_min_limit);
	rChild->max.set(BB_max_limit);
	for(i=left+nL;i<=right;i++)
	{
		const Triangle &tri = GETTRI( triIDs->at(i) );
		updateBB( rChild->min , rChild->max , GETVERTEX( tri.p[0] ).v );
		updateBB( rChild->min , rChild->max , GETVERTEX( tri.p[1] ).v );
		updateBB( rChild->min , rChild->max , GETVERTEX( tri.p[2] ).v );
	}

	if( nR <= maxNumTrisPerLeaf )
	{
		rChild->indexCount = MAKECHILDCOUNT(nR);
		rChild->indexOffset = curIndex;

		for(i=left+nL;i<=right;i++)
		{
			indexlists[curIndex++] = triIndexList[triIDs->at(i)];
			progBuildTree->step();
		}
		treeStats.numLeafs++;
		treeStats.sumDepth += depth;
		treeStats.sumTris += nR;
	}
	else
	{
		//SubdivideSAH( triIDs , left + nL , right , nextIndex + 1 , nextIndex + 2 * nL , depth+1);
		SubdivideSAH( triIDs , left + nL , right , nextIndex + 1 , treeStats.numNodes , depth+1);
	}

	

	return true;
}


void BVH::renderSplit(int axisNr, float splitCoord, Vector3 min, Vector3 max,TriangleIndexList *newlists[2]) {	
}

bool BVH::saveToFile(const char* filename) {	
	LogManager *log = LogManager::getSingletonPtr();	
	char output[255];
	size_t ret;
	FILE *fp = fopen(filename, "wb");

	if (fp == NULL) {
		sprintf(output, "Could not open BSP tree file '%s'!", filename);
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	sprintf(output, "Saving BSP tree to file '%s'...", filename);
	log->logMessage(LOG_INFO, output);

	// write header and version:
	fwrite(BSP_FILEIDSTRING, 1, BSP_FILEIDSTRINGLEN, fp);
	fputc(BSP_FILEVERSION, fp);

	// write stats:
	fwrite(&treeStats, sizeof(BSPTreeInfo), 1, fp);

	// write tree node array:
	sprintf(output, "  ... writing %d tree nodes ...", treeStats.numNodes);
	log->logMessage(LOG_INFO, output);
	ret = fwrite(tree, sizeof(BSPArrayTreeNode), treeStats.numNodes, fp);

	if (ret != treeStats.numNodes) {
		sprintf(output, "Could only write %u nodes, expecting %u!", ret, treeStats.numNodes);
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	// write tri index array
	sprintf(output, "  ... writing %d tri indices ...", treeStats.sumTris);
	log->logMessage(LOG_INFO, output);
	ret = fwrite(indexlists, sizeof(unsigned int), treeStats.sumTris, fp);

	if (ret != treeStats.sumTris) {
		sprintf(output, "Could only write %u indices, expecting %u!", ret, treeStats.sumTris);
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	sprintf(output, "  done!");
	log->logMessage(LOG_INFO, output);
	fclose(fp);

	return true;
}

bool BVH::saveToFile(const char* fileNameHeader, const char* fileNameTree, const char* fileNameIndex) {	
	LogManager *log = LogManager::getSingletonPtr();	
	char output[255];
	size_t ret;
	FILE *fpHeader = fopen(fileNameHeader, "wb");
	FILE *fpTree = fopen(fileNameTree, "wb");
	FILE *fpIndex = fopen(fileNameIndex, "wb");

	if (fpHeader == NULL || fpTree == NULL || fpIndex == NULL) {
		sprintf(output, "Could not open file!");
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	// write header and version:
	fwrite(BSP_FILEIDSTRING, 1, BSP_FILEIDSTRINGLEN, fpHeader);
	fputc(BSP_FILEVERSION, fpHeader);

	// write stats:
	fwrite(&treeStats, sizeof(BSPTreeInfo), 1, fpHeader);

	sprintf(output, "Saving BSP tree to file '%s'...", fpTree);
	log->logMessage(LOG_INFO, output);

	// write tree node array:
	sprintf(output, "  ... writing %d tree nodes ...", treeStats.numNodes);
	log->logMessage(LOG_INFO, output);

	for(unsigned int i=0;i<treeStats.numNodes;i++)
	{
		ret = fwrite(tree+i, sizeof(BSPArrayTreeNode), 1, fpTree);
		if (ret != 1) {
			sprintf(output, "Could only write %u nodes, expecting %u!", i, treeStats.numNodes);
			log->logMessage(LOG_ERROR, output);
			return false;
		}
	}


	// write tri index array
	sprintf(output, "  ... writing %d tri indices ...", treeStats.sumTris);
	log->logMessage(LOG_INFO, output);

	for(unsigned int i=0;i<treeStats.sumTris;i++)
	{
		ret = fwrite(indexlists+i, sizeof(unsigned int), 1, fpIndex);
		if (ret != 1) {
			sprintf(output, "Could only write %u indices, expecting %u!", i, treeStats.sumTris);
			log->logMessage(LOG_ERROR, output);
			return false;
		}
	}

	sprintf(output, "  done!");
	log->logMessage(LOG_INFO, output);
	
	fclose(fpHeader);
	fclose(fpTree);
	fclose(fpIndex);

	return true;
}

bool BVH::loadFromFile(const char* filename) {	
	LogManager *log = LogManager::getSingletonPtr();	
	char output[1000];
	char header[100];
	char bspfilestring[50];
	size_t ret;
	FILE *fp = fopen(filename, "rb");

	if (fp == NULL) {
		sprintf(output, "Could not open BSP tree file '%s'!", filename);
		log->logMessage(LOG_WARNING, output);
		return false;
	}

	sprintf(output, "Loading BSP tree from file '%s'...", filename);
	log->logMessage(LOG_INFO, output);

	ret = fread(header, 1, BSP_FILEIDSTRINGLEN + 1, fp);
	if (ret != (BSP_FILEIDSTRINGLEN + 1)) {
		sprintf(output, "Could not read header from BSP tree file '%s', aborting. (empty file?)", filename);
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	// test header format:
	strcpy(bspfilestring, BSP_FILEIDSTRING);
	for (unsigned int i = 0; i < BSP_FILEIDSTRINGLEN; i++)
		if (header[i] != bspfilestring[i]) {
			printf(output, "Invalid BSP tree header, aborting. (expected:'%c', found:'%c')", bspfilestring[i], header[i]);
			log->logMessage(LOG_ERROR, output);
			return false;		
		}

		// test file version:
		if (header[BSP_FILEIDSTRINGLEN] != BSP_FILEVERSION) {
			printf(output, "Wrong BSP tree file version (expected:%d, found:%d)", BSP_FILEVERSION, header[BSP_FILEIDSTRINGLEN]);
			log->logMessage(LOG_ERROR, output);
			return false;		
		}

		// format correct, read in full BSP tree info structure:

		// write count of nodes and tri indices:
		ret = fread(&treeStats, sizeof(BSPTreeInfo), 1, fp);
		if (ret != 1) {
			sprintf(output, "Could not read tree info header!");
			log->logMessage(LOG_ERROR, output);
			return false;
		}

		sprintf(output, "Allocating memory...");
		//log->logMessage(LOG_INFO, output);

		tree = new BSPArrayTreeNode[treeStats.numNodes];	
		indexlists = new int[treeStats.sumTris];

		// write tree node array:
		sprintf(output, "  ... reading %d tree nodes ...", treeStats.numNodes);
		//log->logMessage(LOG_INFO, output);
		ret = fread(tree, sizeof(BSPArrayTreeNode), treeStats.numNodes, fp);

		if (ret != treeStats.numNodes) {
			sprintf(output, "Could only read %u nodes, expecting %u!", ret, treeStats.numNodes);
			log->logMessage(LOG_ERROR, output);
			return false;
		}

		// write tri index array
		sprintf(output, "  ... reading %d tri indices ...", treeStats.sumTris);
		//log->logMessage(LOG_INFO, output);
		ret = fread(indexlists, sizeof(int), treeStats.sumTris, fp);

		if (ret != treeStats.sumTris) {
			sprintf(output, "Could only read %u indices, expecting %u!", ret, treeStats.sumTris);
			log->logMessage(LOG_ERROR, output);
			return false;
		}

		sprintf(output, "  done!");
		//log->logMessage(LOG_INFO, output);
		fclose(fp);

		return true;
}	

bool BVH::loadFromFiles(const char* filename) {	
	LogManager *log = LogManager::getSingletonPtr();	
	char filenameNodes[MAX_PATH], fileNameIndices[MAX_PATH];
	char output[1000];
	char header[100];
	char bspfilestring[50];
	size_t ret;

	sprintf(filenameNodes, "%s.node", filename);
	sprintf(fileNameIndices, "%s.idx", filename);

	FILE *fp = fopen(filename, "rb");
	FILE *fpNodes = fopen(filenameNodes, "rb");
	FILE *fpIndices = fopen(fileNameIndices, "rb");

	if (fp == NULL) {
		sprintf(output, "Could not open BSP tree file '%s'!", filename);
		log->logMessage(LOG_WARNING, output);
		return false;
	}

	if (fpNodes == NULL) {
		sprintf(output, "Could not open BSP tree file '%s'!", filenameNodes);
		log->logMessage(LOG_WARNING, output);
		fclose(fp);
		return false;
	}

	if (fpIndices == NULL) {
		sprintf(output, "Could not open BSP tree file '%s'!", fileNameIndices);
		log->logMessage(LOG_WARNING, output);
		fclose(fp);
		fclose(fpNodes);
		return false;
	}

	sprintf(output, "Loading BSP tree from files ('%s')...", filename);
	log->logMessage(LOG_INFO, output);

	ret = fread(header, 1, BSP_FILEIDSTRINGLEN + 1, fp);
	if (ret != (BSP_FILEIDSTRINGLEN + 1)) {
		sprintf(output, "Could not read header from BSP tree file '%s', aborting. (empty file?)", filename);
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	// test header format:
	strcpy(bspfilestring, BSP_FILEIDSTRING);
	for (unsigned int i = 0; i < BSP_FILEIDSTRINGLEN; i++) {
		if (header[i] != bspfilestring[i]) {
			printf(output, "Invalid BSP tree header, aborting. (expected:'%c', found:'%c')", bspfilestring[i], header[i]);
			log->logMessage(LOG_ERROR, output);
			return false;		
		}
	}

	// test file version:
	if (header[BSP_FILEIDSTRINGLEN] != BSP_FILEVERSION) {
		printf(output, "Wrong BSP tree file version (expected:%d, found:%d)", BSP_FILEVERSION, header[BSP_FILEIDSTRINGLEN]);
		log->logMessage(LOG_ERROR, output);
		return false;		
	}

	// format correct, read in full BSP tree info structure:

	// write count of nodes and tri indices:
	ret = fread(&treeStats, sizeof(BSPTreeInfo), 1, fp);
	if (ret != 1) {
		sprintf(output, "Could not read tree info header!");
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	sprintf(output, "Allocating memory...");
	log->logMessage(LOG_INFO, output);

	tree = new BSPArrayTreeNode[treeStats.numNodes];	
	indexlists = new int[treeStats.sumTris];

	// write tree node array:
	sprintf(output, "  ... reading %d tree nodes ...", treeStats.numNodes);
	log->logMessage(LOG_INFO, output);
	ret = fread(tree, sizeof(BSPArrayTreeNode), treeStats.numNodes, fpNodes);

	if (ret != treeStats.numNodes) {
		sprintf(output, "Could only read %u nodes, expecting %u!", ret, treeStats.numNodes);
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	// write tri index array
	sprintf(output, "  ... reading %d tri indices ...", treeStats.sumTris);
	log->logMessage(LOG_INFO, output);
	ret = fread(indexlists, sizeof(int), treeStats.sumTris, fpIndices);

	if (ret != treeStats.sumTris) {
		sprintf(output, "Could only read %u indices, expecting %u!", ret, treeStats.sumTris);
		log->logMessage(LOG_ERROR, output);
		return false;
	}

	sprintf(output, "  done!");
	log->logMessage(LOG_INFO, output);
	fclose(fp);
	fclose(fpNodes);
	fclose(fpIndices);

	return true;
}	

void BVH::printNodeInArray(const char *LoggerName, BSPArrayTreeNodePtr current, int depth) {

	LogManager *log = LogManager::getSingletonPtr();
	char outStr[500];
	char indent[100];
	char *axis = "XYZL";
	int axisNr;
	int numTris = 0;
	BSPArrayTreeNodePtr child_left, child_right;

	indent[0] = 0;
	if (depth > 0) {
		int i;
		for (i = 0; i < (depth-1)*2; i++) {
			indent[i]   = ' ';			
		}
		indent[i]   = '|';
		indent[i+1] = '-';		
		indent[depth*2] = 0;
	}
	else if (depth == 0) {
		if (tree == NULL)
			return;
		current = &tree[0];		
	}

	// find axis (encoded in the lower two bits)	
	axisNr = AXIS(current);
	child_left = GETNODE(GETLEFTCHILD(current));
	child_right = GETNODE(GETRIGHTCHILD(current));

	
	if (ISNOLEAF(current)) {
		printNodeInArray(LoggerName, child_left, depth + 1);		
		printNodeInArray(LoggerName, child_right, depth + 1);
	}

}

void BVH::printTree(bool dumpTree, const char *LoggerName) {
	LogManager *log = LogManager::getSingletonPtr();
	char outputBuffer[2000];
	log->logMessage("-------------------------------------------", LoggerName);
	log->logMessage("BSP Tree Statistics", LoggerName);
	log->logMessage("-------------------------------------------", LoggerName);
	sprintf(outputBuffer, "Time to build:\t%d seconds, %d milliseconds", (int)treeStats.timeBuild, (int)((treeStats.timeBuild - floor(treeStats.timeBuild)) * 1000));
	log->logMessage(outputBuffer, LoggerName);
	sprintf(outputBuffer, "Triangles:\t%d", treeStats.numTris);
	log->logMessage(outputBuffer, LoggerName);
	sprintf(outputBuffer, "Nodes:\t\t%d", treeStats.numNodes);
	log->logMessage(outputBuffer, LoggerName);
	sprintf(outputBuffer, "Leafs:\t\t%d", treeStats.numLeafs);
	log->logMessage(outputBuffer, LoggerName);
	sprintf(outputBuffer, "Max. leaf depth:\t%d (of %d)", treeStats.maxLeafDepth, treeStats.maxDepth);
	log->logMessage(outputBuffer, LoggerName);
	sprintf(outputBuffer, "Max. tri count/leaf:\t%d", treeStats.maxTriCountPerLeaf);
	log->logMessage(outputBuffer, LoggerName);
	if (treeStats.numLeafs > 0) {
		sprintf(outputBuffer, "Avg. leaf depth:\t%.2f", (float)treeStats.sumDepth / (float)treeStats.numLeafs);
		log->logMessage(outputBuffer, LoggerName);

		sprintf(outputBuffer, "Avg. tris/leaf:\t%.2f", (float)treeStats.sumTris / (float)treeStats.numLeafs);
		log->logMessage(outputBuffer, LoggerName);

		sprintf(outputBuffer, "Tri refs total:\t\t%d", treeStats.sumTris);
		log->logMessage(outputBuffer, LoggerName);

	}
	sprintf(outputBuffer, "Used memory:\t%d KB", (treeStats.numNodes*sizeof(BSPArrayTreeNode) + (treeStats.sumTris * sizeof(int))) / 1024);
	log->logMessage(outputBuffer, LoggerName);

	
	if (dumpTree) {		
		log->logMessage("-------------------------------------------", LoggerName);
		log->logMessage("BSP Tree structure", LoggerName);
		log->logMessage("-------------------------------------------", LoggerName);		
		printNodeInArray(LoggerName, NULL, 0);
		log->logMessage("-------------------------------------------", LoggerName);		
	}
}
int BVH::getNumTris() {
	return treeStats.numTris;
}
#endif